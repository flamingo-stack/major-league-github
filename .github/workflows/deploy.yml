name: Build and Deploy Major League Github on GCP üöÄ ‚òÅÔ∏è

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  PROJECT_NAME: ${{ secrets.PROJECT_NAME }}
  VERSION: v1.0.${{ github.run_number }}
  ENVIRONMENT: production
  
  # Google Tag Manager
  GTM_ID: ${{ secrets.GTM_ID }}
  
  # GCP Configuration
  GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  GKE_CLUSTER: ${{ secrets.GKE_CLUSTER }}
  GKE_ZONE: ${{ secrets.GKE_ZONE }}
  
  # GitHub Container Registry
  REGISTRY: ghcr.io
  REGISTRY_NAME: ${{ github.repository }}
  
  # Kubernetes namespace (convert repo name to valid namespace)
  NAMESPACE: ${{ github.event.repository.name }}

  DOMAIN_NAME: ${{ secrets.DOMAIN_NAME }}
  DOMAIN_SUFFIX: ${{ secrets.DOMAIN_SUFFIX }}
  STATIC_IP_NAME: "main-ingress-ip"
  STATIC_IP_ADDRESS: ${{ secrets.STATIC_IP_ADDRESS }}

  GH_API_TOKENS: ${{ secrets.GH_API_TOKENS }}
  
  # LinkedIn
  LINKEDIN_CLIENT_ID: ${{ secrets.LINKEDIN_CLIENT_ID }}
  LINKEDIN_CLIENT_SECRET: ${{ secrets.LINKEDIN_CLIENT_SECRET }}
  
  # Resource configuration
  BACKEND_REPLICAS: 1
  FRONTEND_REPLICAS: 1
  
  # Backend resources (minimal for single-node cluster)
  BACKEND_REQUEST_MEMORY: 256Mi
  BACKEND_REQUEST_CPU: 50m
  BACKEND_LIMIT_MEMORY: 1Gi
  BACKEND_LIMIT_CPU: 500m
  
  # Frontend resources (minimal for single-node cluster)
  FRONTEND_REQUEST_MEMORY: 64Mi
  FRONTEND_REQUEST_CPU: 25m
  FRONTEND_LIMIT_MEMORY: 256Mi
  FRONTEND_LIMIT_CPU: 200m
  
  # Java settings
  JAVA_MAX_HEAP: 1200m
  JAVA_MIN_HEAP: 512m
  
  # Redis Configuration
  REDIS_HOST: ${{ secrets.REDIS_IP }}

jobs:
  build-and-deploy:
    runs-on: ubuntu-22.04
    permissions:
      contents: read
      packages: write
      deployments: write

    steps:
      - name: Verify Required Secrets üîí
        run: |
          missing_secrets=()
          
          # Core project secrets
          if [ -z "${{ secrets.PROJECT_NAME }}" ]; then
            missing_secrets+=("PROJECT_NAME")
          fi
          
          # GCP Infrastructure secrets
          if [ -z "${{ secrets.GCP_PROJECT_ID }}" ]; then
            missing_secrets+=("GCP_PROJECT_ID")
          fi
          
          if [ -z "${{ secrets.GCP_SA_KEY }}" ]; then
            missing_secrets+=("GCP_SA_KEY")
          fi
          
          if [ -z "${{ secrets.GKE_CLUSTER }}" ]; then
            missing_secrets+=("GKE_CLUSTER")
          fi
          
          if [ -z "${{ secrets.GKE_ZONE }}" ]; then
            missing_secrets+=("GKE_ZONE")
          fi
          
          # Container Registry auto-detected from repository
          
          # DNS secrets
          if [ -z "${{ secrets.DNS_PROJECT_ID }}" ]; then
            missing_secrets+=("DNS_PROJECT_ID")
          fi
          
          if [ -z "${{ secrets.DNS_ZONE }}" ]; then
            missing_secrets+=("DNS_ZONE")
          fi
          
          # Redis secret
          if [ -z "${{ secrets.REDIS_IP }}" ]; then
            missing_secrets+=("REDIS_IP")
          fi
          
          # Domain secrets
          if [ -z "${{ secrets.DOMAIN_NAME }}" ]; then
            missing_secrets+=("DOMAIN_NAME")
          fi
          
          if [ -z "${{ secrets.DOMAIN_SUFFIX }}" ]; then
            missing_secrets+=("DOMAIN_SUFFIX")
          fi
          
          # Application secrets
          if [ -z "${{ secrets.GH_API_TOKENS }}" ]; then
            missing_secrets+=("GH_API_TOKENS")
          fi
          
          if [ -z "${{ secrets.LINKEDIN_CLIENT_ID }}" ]; then
            missing_secrets+=("LINKEDIN_CLIENT_ID")
          fi
          
          if [ -z "${{ secrets.LINKEDIN_CLIENT_SECRET }}" ]; then
            missing_secrets+=("LINKEDIN_CLIENT_SECRET")
          fi
          
          if [ -z "${{ secrets.GTM_ID }}" ]; then
            missing_secrets+=("GTM_ID")
          fi
          
          if [ ${#missing_secrets[@]} -ne 0 ]; then
            echo "‚ùå Error: Missing required secrets: ${missing_secrets[*]}"
            exit 1
          fi
          
          echo "‚úÖ All required secrets are set"

      - name: Checkout code üì¶
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Google Cloud CLI üõ†Ô∏è
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Configure gcloud üîß
        uses: google-github-actions/setup-gcloud@v2

      - name: Get GKE credentials üîë
        uses: google-github-actions/get-gke-credentials@v2
        with:
          cluster_name: ${{ env.GKE_CLUSTER }}
          location: ${{ env.GKE_ZONE }}

      - name: Login to GitHub Container Registry üê≥
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Check for changes üîç
        id: changes
        run: |
          echo "üîç Checking for changes since last successful build..."
          
          # Get the last successful workflow run SHA
          LAST_SUCCESS_SHA=$(gh run list --workflow=deploy.yml --status=success --limit=1 --json headSha --jq='.[0].headSha' || echo "")
          
          if [ -z "$LAST_SUCCESS_SHA" ] || [ "$LAST_SUCCESS_SHA" = "null" ]; then
            echo "No previous successful build found, building all images"
            echo "build_backend=true" >> $GITHUB_OUTPUT
            echo "build_cache_updater=true" >> $GITHUB_OUTPUT
            echo "build_frontend=true" >> $GITHUB_OUTPUT
          else
            echo "Comparing changes since $LAST_SUCCESS_SHA"
            
            # Check for backend changes
            if git diff --name-only $LAST_SUCCESS_SHA..HEAD | grep -E '^backend/|^kubernetes/.*backend|^\.github/workflows/deploy\.yml$' > /dev/null; then
              echo "Backend changes detected"
              echo "build_backend=true" >> $GITHUB_OUTPUT
            else
              echo "No backend changes detected"
              echo "build_backend=false" >> $GITHUB_OUTPUT
            fi
            
            # Check for cache updater changes (same as backend since it uses same source)
            if git diff --name-only $LAST_SUCCESS_SHA..HEAD | grep -E '^backend/|^kubernetes/.*cache|^\.github/workflows/deploy\.yml$' > /dev/null; then
              echo "Cache updater changes detected"
              echo "build_cache_updater=true" >> $GITHUB_OUTPUT
            else
              echo "No cache updater changes detected"
              echo "build_cache_updater=false" >> $GITHUB_OUTPUT
            fi
            
            # Check for frontend changes
            if git diff --name-only $LAST_SUCCESS_SHA..HEAD | grep -E '^frontend/|^kubernetes/.*frontend|^\.github/workflows/deploy\.yml$' > /dev/null; then
              echo "Frontend changes detected"
              echo "build_frontend=true" >> $GITHUB_OUTPUT
            else
              echo "No frontend changes detected"
              echo "build_frontend=false" >> $GITHUB_OUTPUT
            fi
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Set Webapp Environment Variables üé®
        run: |
          # Set OG Meta Tags environment variables
          echo "OG_TITLE=Major League GitHub" >> $GITHUB_ENV
          echo "OG_DESCRIPTION=GitHub Scouting Report: Major League Edition" >> $GITHUB_ENV
          echo "OG_TYPE=website" >> $GITHUB_ENV
          echo "OG_IMAGE_URL=/og-image.png" >> $GITHUB_ENV
          echo "OG_SITE_NAME=Major League GitHub" >> $GITHUB_ENV
          
          # Set Extra Button environment variables
          echo "WEBAPP_EXTRA_BUTTON_LINK=https://medium.com/@michaelassraf/major-league-github-the-open-source-talent-leaderboard-ca2c6d7dcbeb" >> $GITHUB_ENV
          echo "WEBAPP_EXTRA_BUTTON_TEXT=Why MLG?" >> $GITHUB_ENV

      - name: Build and push backend service image üèóÔ∏è
        if: steps.changes.outputs.build_backend == 'true'
        run: |
          echo "üöÄ Building backend service image..."
          docker build \
            --build-arg PROFILE=backend-service \
            -t ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/backend-service:${{ env.VERSION }} \
            -t ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/backend-service:latest \
            backend
          
          echo "üöÄ Pushing backend service images..."
          docker push ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/backend-service:${{ env.VERSION }}
          docker push ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/backend-service:latest

      - name: Skip backend service build üèóÔ∏è
        if: steps.changes.outputs.build_backend == 'false'
        run: echo "‚è© Skipping backend service build - no changes detected"

      - name: Build and push cache updater image üèóÔ∏è
        if: steps.changes.outputs.build_cache_updater == 'true'
        run: |
          echo "üöÄ Building cache updater image..."
          docker build \
            --build-arg PROFILE=cache-updater \
            -t ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/cache-updater:${{ env.VERSION }} \
            -t ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/cache-updater:latest \
            backend
          
          echo "üöÄ Pushing cache updater images..."
          docker push ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/cache-updater:${{ env.VERSION }}
          docker push ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/cache-updater:latest

      - name: Skip cache updater build üèóÔ∏è
        if: steps.changes.outputs.build_cache_updater == 'false'
        run: echo "‚è© Skipping cache updater build - no changes detected"

      - name: Build and push frontend image üé®
        if: steps.changes.outputs.build_frontend == 'true'
        env:
          OG_TITLE: ${{ env.OG_TITLE }}
          OG_DESCRIPTION: ${{ env.OG_DESCRIPTION }}
          OG_TYPE: ${{ env.OG_TYPE }}
          OG_IMAGE_URL: ${{ env.OG_IMAGE_URL }}
          OG_SITE_NAME: ${{ env.OG_SITE_NAME }}
          WEBAPP_EXTRA_BUTTON_LINK: ${{ env.WEBAPP_EXTRA_BUTTON_LINK }}
          WEBAPP_EXTRA_BUTTON_TEXT: ${{ env.WEBAPP_EXTRA_BUTTON_TEXT }}
        run: |
          echo "üöÄ Building frontend image..."
          docker build frontend \
            --build-arg NODE_ENV=production \
            --build-arg BACKEND_API_URL="https://${{ env.DOMAIN_NAME }}.${{ env.DOMAIN_SUFFIX }}" \
            --build-arg GTM_ID="${{ env.GTM_ID }}" \
            --build-arg OG_TITLE="${{ env.OG_TITLE }}" \
            --build-arg OG_DESCRIPTION="${{ env.OG_DESCRIPTION }}" \
            --build-arg OG_TYPE="${{ env.OG_TYPE }}" \
            --build-arg OG_IMAGE_URL="${{ env.OG_IMAGE_URL }}" \
            --build-arg OG_URL="https://${{ env.DOMAIN_NAME }}.${{ env.DOMAIN_SUFFIX }}" \
            --build-arg OG_SITE_NAME="${{ env.OG_SITE_NAME }}" \
            --build-arg WEBAPP_EXTRA_BUTTON_LINK="${{ env.WEBAPP_EXTRA_BUTTON_TEXT }}" \
            --build-arg WEBAPP_EXTRA_BUTTON_TEXT="${{ env.WEBAPP_EXTRA_BUTTON_TEXT }}" \
            -t "${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/frontend:${{ env.VERSION }}" \
            -t "${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/frontend:latest"
          
          echo "üöÄ Pushing frontend images..."
          docker push ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/frontend:${{ env.VERSION }}
          docker push ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/frontend:latest

      - name: Skip frontend build üé®
        if: steps.changes.outputs.build_frontend == 'false'
        run: echo "‚è© Skipping frontend build - no changes detected"

      - name: Create Kubernetes namespace and secrets üîê
        run: |
          # Create namespace
          kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
          
          # Create application secrets
          kubectl create secret generic app-secrets \
            --namespace=${{ env.NAMESPACE }} \
            --from-literal=github.tokens="${{ env.GH_API_TOKENS }}" \
            --from-literal=linkedin.client.id="${{ env.LINKEDIN_CLIENT_ID }}" \
            --from-literal=linkedin.client.secret="${{ env.LINKEDIN_CLIENT_SECRET }}" \
            --dry-run=client -o yaml | kubectl apply -f -
          
          echo "‚úÖ Kubernetes secrets created successfully"

      - name: Cleanup GKE Resources üßπ
        run: |
          echo "üßπ Cleaning up all existing resources in namespace ${{ env.NAMESPACE }}..."
          
          # Clean up all resources in namespace (except secrets and configmaps we'll recreate)
          kubectl delete all --all -n ${{ env.NAMESPACE }} --ignore-not-found=true || echo "No standard resources to clean up"
          kubectl delete ingress --all -n ${{ env.NAMESPACE }} --ignore-not-found=true || echo "No ingress resources to clean up"
          kubectl delete backendconfig --all -n ${{ env.NAMESPACE }} --ignore-not-found=true || echo "No backendconfig resources to clean up"
          
          # Wait for NEG cleanup to complete (they take time to detach from load balancers)
          echo "‚è≥ Waiting for NEG cleanup to complete..."
          sleep 30
          
          echo "‚úÖ Cleanup completed successfully"

      - name: Deploy to GKE üöÄ
        env:
          REGISTRY_URL: ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}
          DOMAIN_SUFFIX: ${{ env.DOMAIN_SUFFIX }}
          DOMAIN_NAME: ${{ env.DOMAIN_NAME }}
          ENVIRONMENT: ${{ env.ENVIRONMENT }}
          VERSION: ${{ env.VERSION }}
          BACKEND_SERVICE_NAME: "backend-service"
          CACHE_UPDATER_NAME: "cache-updater" 
          BACKEND_SERVICE_PORT: "8080"
          CACHE_UPDATER_PORT: "8081"
          FRONTEND_PORT: "80"
          STATIC_IP_ADDRESS: ${{ secrets.STATIC_IP_ADDRESS }}
        run: |
          echo "üöÄ Processing and applying Kubernetes configurations..."
          
          # Determine image versions based on what was built
          if [ "${{ steps.changes.outputs.build_backend }}" = "true" ]; then
            BACKEND_VERSION="${{ env.VERSION }}"
            echo "‚úÖ Using new backend version: $BACKEND_VERSION"
          else
            BACKEND_VERSION="latest"
            echo "‚è© Using existing backend version: $BACKEND_VERSION"
          fi
          
          if [ "${{ steps.changes.outputs.build_cache_updater }}" = "true" ]; then
            CACHE_UPDATER_VERSION="${{ env.VERSION }}"
            echo "‚úÖ Using new cache updater version: $CACHE_UPDATER_VERSION"
          else
            CACHE_UPDATER_VERSION="latest"
            echo "‚è© Using existing cache updater version: $CACHE_UPDATER_VERSION"
          fi
          
          if [ "${{ steps.changes.outputs.build_frontend }}" = "true" ]; then
            FRONTEND_VERSION="${{ env.VERSION }}"
            echo "‚úÖ Using new frontend version: $FRONTEND_VERSION"
          else
            FRONTEND_VERSION="latest"
            echo "‚è© Using existing frontend version: $FRONTEND_VERSION"
          fi
          
          # Create temporary directory
          mkdir -p processed_k8s
          
          # Process config files
          echo "üöÄ Processing config.yaml..."
          envsubst < kubernetes/base/config.yaml > processed_k8s/config.yaml
          kubectl apply -n ${{ env.NAMESPACE }} -f processed_k8s/config.yaml
          
          # Process and apply backend service
          echo "üöÄ Processing backend service..."
          SERVICE_NAME=backend-service \
          SERVER_PORT=8080 \
          VERSION=$BACKEND_VERSION \
            envsubst < kubernetes/base/backend-service.yaml > processed_k8s/backend-service.yaml
          kubectl apply -n ${{ env.NAMESPACE }} -f processed_k8s/backend-service.yaml
          
          # Process and apply cache updater
          echo "üöÄ Processing cache updater..."
          SERVICE_NAME=cache-updater \
          SERVER_PORT=8081 \
          VERSION=$CACHE_UPDATER_VERSION \
            envsubst < kubernetes/base/cache-updater-service.yaml > processed_k8s/cache-updater.yaml
          kubectl apply -n ${{ env.NAMESPACE }} -f processed_k8s/cache-updater.yaml
          
          # Process and apply frontend (creates frontend-service as ClusterIP with NEG)
          echo "üöÄ Processing frontend..."
          VERSION=$FRONTEND_VERSION \
            envsubst < kubernetes/base/frontend.yaml > processed_k8s/frontend.yaml
          kubectl apply -n ${{ env.NAMESPACE }} -f processed_k8s/frontend.yaml
          echo "‚úÖ Frontend applied successfully"
          
          echo "‚úÖ All resources cleanup completed"
          
          # Check deployment status immediately after creation
          echo "üîç Immediate deployment status check..."
          kubectl get deployments -n ${{ env.NAMESPACE }} -o wide
          kubectl get pods -n ${{ env.NAMESPACE }} -o wide
          kubectl get events -n ${{ env.NAMESPACE }} --sort-by='.lastTimestamp' | tail -20
          
          echo "üîç Cache-updater specific details:"
          kubectl describe deployment/cache-updater -n ${{ env.NAMESPACE }}
          echo "üîç Cache-updater pod details:"
          kubectl describe pods -n ${{ env.NAMESPACE }} -l app=cache-updater
          echo "üîç Cache-updater logs (if any):"
          kubectl logs -n ${{ env.NAMESPACE }} -l app=cache-updater --tail=50 || echo "No logs yet"
          
          # Wait for deployments to be ready
          echo "üöÄ Now waiting for deployments to be ready..."
          kubectl wait --for=condition=available deployment/backend-service -n ${{ env.NAMESPACE }} --timeout=300s
          kubectl wait --for=condition=available deployment/cache-updater -n ${{ env.NAMESPACE }} --timeout=300s
          kubectl wait --for=condition=available deployment/frontend -n ${{ env.NAMESPACE }} --timeout=300s
          
          # Create static IP if it doesn't exist
          echo "üöÄ Ensuring static IP exists..."
          if ! gcloud compute addresses describe main-ingress-ip --global >/dev/null 2>&1; then
            echo "Creating static IP main-ingress-ip with address ${STATIC_IP_ADDRESS}..."
            gcloud compute addresses create main-ingress-ip --global --addresses=${STATIC_IP_ADDRESS}
          else
            echo "Static IP main-ingress-ip already exists"
          fi
          
          # Create ingress AFTER all services exist with static IP
          echo "üöÄ Processing ingress after services are ready..."
          envsubst < kubernetes/base/ingress.yaml > processed_k8s/ingress.yaml
          kubectl apply -n ${{ env.NAMESPACE }} -f processed_k8s/ingress.yaml
          
          # Cleanup
          rm -rf processed_k8s
          
          echo "‚úÖ Deployment completed successfully"

      - name: Verify Deployment üîç
        run: |
          echo "üîç Checking deployment status..."
          
          echo "Pod Status:"
          kubectl -n ${{ env.NAMESPACE }} get pods -o wide
          
          echo "Service Status:"
          kubectl -n ${{ env.NAMESPACE }} get services
          
          echo "LoadBalancer Status:"
          kubectl -n ${{ env.NAMESPACE }} get ingress main-ingress -o wide
          
          # Use static IP instead of waiting for dynamic assignment
          LB_IP="${{ env.STATIC_IP_ADDRESS }}"
          echo "‚úÖ Using static IP: ${LB_IP}"
          echo "üåê Frontend URL: http://${LB_IP}/"
          echo "üåê Backend API URL: http://${LB_IP}/api/actuator/health"
          
          echo "‚úÖ Migration Complete - Proper Kubernetes Architecture!"
          echo "üåê Single External Gateway: http://${LB_IP}"
          echo "   - Frontend: http://${LB_IP}/"
          echo "   - API: http://${LB_IP}/api"
          echo ""
          echo "üîí Internal Services (ClusterIP only):"
          echo "   - frontend-service:80 (internal)"
          echo "   - backend-service-service:8080 (internal)"
          echo ""
          echo "üåç Domain: https://${{ env.DOMAIN_NAME }}.${{ env.DOMAIN_SUFFIX }}"

      - name: Update DNS Record (Cross-Project) üåç
        run: |
          LB_IP="${{ env.STATIC_IP_ADDRESS }}"
          echo "üåç Updating DNS record for ${{ env.DOMAIN_NAME }}.${{ env.DOMAIN_SUFFIX }} to ${LB_IP}"
          
          # DNS project details
          DNS_PROJECT_ID="${{ secrets.DNS_PROJECT_ID }}"
          DNS_ZONE="${{ secrets.DNS_ZONE }}"
          
          # Set project context to DNS project
          gcloud config set project $DNS_PROJECT_ID
          
          # Debug: List all DNS zones in the project
          echo "üîç Available DNS zones in project $DNS_PROJECT_ID:"
          gcloud dns managed-zones list --project=$DNS_PROJECT_ID --format="table(name,dnsName)" || echo "No zones found or permission denied"
          
          echo "üîç Looking for DNS zone: $DNS_ZONE"
          
          # Check if DNS zone exists
          if ! gcloud dns managed-zones describe $DNS_ZONE --project=$DNS_PROJECT_ID --format="value(name)" > /dev/null 2>&1; then
            echo "‚ùå Cloud DNS zone '$DNS_ZONE' not found in project $DNS_PROJECT_ID"
            echo "üåç FALLBACK - Manual DNS Update Required:"
            echo "Load Balancer IP: ${LB_IP}"
            echo "Go to: https://console.cloud.google.com/net-services/dns/zones?project=$DNS_PROJECT_ID"
            exit 1
          fi
          
          # Get existing A record if it exists
          EXISTING_IP=$(gcloud dns record-sets list --zone=$DNS_ZONE --project=$DNS_PROJECT_ID --name="${{ env.DOMAIN_NAME }}.${{ env.DOMAIN_SUFFIX }}." --type=A --format="value(rrdatas[0])" 2>/dev/null | head -1 || echo "")
          
          if [ ! -z "$EXISTING_IP" ] && [ "$EXISTING_IP" != "null" ] && [ "$EXISTING_IP" != "$LB_IP" ]; then
            echo "üåç Updating existing A record from $EXISTING_IP to $LB_IP"
            
            # Get the existing record with full details including TTL
            EXISTING_TTL=$(gcloud dns record-sets list --zone=$DNS_ZONE --project=$DNS_PROJECT_ID --name="${{ env.DOMAIN_NAME }}.${{ env.DOMAIN_SUFFIX }}." --type=A --format="value(ttl)" 2>/dev/null | head -1)
            
            if [ ! -z "$EXISTING_TTL" ] && [ "$EXISTING_TTL" != "null" ]; then
              echo "Found existing record: TTL=$EXISTING_TTL, IP=$EXISTING_IP"
              
              # Use transaction to update the record with exact existing values
              gcloud dns record-sets transaction start --zone=$DNS_ZONE --project=$DNS_PROJECT_ID
              gcloud dns record-sets transaction remove "$EXISTING_IP" \
                --name="${{ env.DOMAIN_NAME }}.${{ env.DOMAIN_SUFFIX }}." \
                --ttl=$EXISTING_TTL \
                --type=A \
                --zone=$DNS_ZONE --project=$DNS_PROJECT_ID
              gcloud dns record-sets transaction add "$LB_IP" \
                --name="${{ env.DOMAIN_NAME }}.${{ env.DOMAIN_SUFFIX }}." \
                --ttl=300 \
                --type=A \
                --zone=$DNS_ZONE --project=$DNS_PROJECT_ID
              gcloud dns record-sets transaction execute --zone=$DNS_ZONE --project=$DNS_PROJECT_ID
            else
              echo "Could not find existing record details, will create new record instead"
              # Fall back to creating new record
              gcloud dns record-sets transaction start --zone=$DNS_ZONE --project=$DNS_PROJECT_ID
              gcloud dns record-sets transaction add "$LB_IP" \
                --name="${{ env.DOMAIN_NAME }}.${{ env.DOMAIN_SUFFIX }}." \
                --ttl=300 \
                --type=A \
                --zone=$DNS_ZONE --project=$DNS_PROJECT_ID
              gcloud dns record-sets transaction execute --zone=$DNS_ZONE --project=$DNS_PROJECT_ID
            fi
            
          elif [ -z "$EXISTING_IP" ] || [ "$EXISTING_IP" = "null" ]; then
            echo "üåç Creating new A record pointing to $LB_IP"
            
            # Create new A record
            gcloud dns record-sets transaction start --zone=$DNS_ZONE --project=$DNS_PROJECT_ID
            gcloud dns record-sets transaction add "$LB_IP" \
              --name="${{ env.DOMAIN_NAME }}.${{ env.DOMAIN_SUFFIX }}." \
              --ttl=300 \
              --type=A \
              --zone=$DNS_ZONE --project=$DNS_PROJECT_ID
            gcloud dns record-sets transaction execute --zone=$DNS_ZONE --project=$DNS_PROJECT_ID
            
          else
            echo "üåç DNS record already points to correct IP: $LB_IP"
          fi
          
          echo "‚úÖ DNS record updated successfully"
          echo "üåç Domain will be accessible at: https://${{ env.DOMAIN_NAME }}.${{ env.DOMAIN_SUFFIX }}"
          echo "‚è≥ DNS propagation may take 5-15 minutes"
          
          # Switch back to original project
          gcloud config set project ${{ env.GCP_PROJECT_ID }}

      - name: Create GitHub Deployment üì¶
        uses: chrnorm/deployment-action@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          environment: production
          initial-status: success
          environment-url: https://${{ env.DOMAIN_NAME }}.${{ env.DOMAIN_SUFFIX }}

      - name: Cleanup old container images üßπ
        if: always()
        run: |
          echo "üßπ Cleaning up old container images..."
          
          # Define image repositories
          REPOS=("backend-service" "cache-updater" "frontend")
          ORG_NAME="flamingo-stack" 
          KEEP_COUNT=3  # Keep this many most recent versioned images (plus 'latest')
          
          for repo in "${REPOS[@]}"; do
            echo "üîç Cleaning up ${ORG_NAME}/${repo}..."
            
            # Get all versions with their metadata
            ALL_VERSIONS=$(gh api \
              "/orgs/${ORG_NAME}/packages/container/${repo}/versions" \
              --jq 'sort_by(.created_at) | reverse' 2>/dev/null || echo "[]")
            
            if [ "$ALL_VERSIONS" = "[]" ]; then
              echo "‚úÖ No versions found for ${repo}"
              continue
            fi
            
            # Get versions to keep (latest + current + N most recent versioned)
            KEEP_LATEST=$(echo "$ALL_VERSIONS" | jq -r '.[] | select(.metadata.container.tags[] == "latest") | .id' | head -1)
            KEEP_CURRENT=$(echo "$ALL_VERSIONS" | jq -r --arg version "${{ env.VERSION }}" '.[] | select(.metadata.container.tags[] == $version) | .id' | head -1)
            
            # Get versioned images (exclude latest and current), keep only most recent N
            VERSIONED_TO_KEEP=$(echo "$ALL_VERSIONS" | jq -r --arg version "${{ env.VERSION }}" '.[] | select((.metadata.container.tags[] != "latest") and (.metadata.container.tags[] != $version)) | .id' | head -$KEEP_COUNT)
            
            # Combine all IDs to keep
            KEEP_IDS=""
            [ ! -z "$KEEP_LATEST" ] && KEEP_IDS="$KEEP_IDS $KEEP_LATEST"
            [ ! -z "$KEEP_CURRENT" ] && KEEP_IDS="$KEEP_CURRENT $KEEP_IDS"
            KEEP_IDS="$KEEP_IDS $VERSIONED_TO_KEEP"
            
            echo "üìã Will keep versions: $KEEP_IDS"
            
            # Delete versions not in keep list
            echo "$ALL_VERSIONS" | jq -r '.[] | .id' | while read version_id; do
              if echo "$KEEP_IDS" | grep -q "$version_id"; then
                TAGS=$(echo "$ALL_VERSIONS" | jq -r --arg id "$version_id" '.[] | select(.id == $id) | .metadata.container.tags[]' | tr '\n' ',' | sed 's/,$//')
                echo "‚è© Keeping version $version_id (tags: $TAGS)"
              else
                TAGS=$(echo "$ALL_VERSIONS" | jq -r --arg id "$version_id" '.[] | select(.id == $id) | .metadata.container.tags[]' | tr '\n' ',' | sed 's/,$//')
                echo "üóëÔ∏è Deleting version $version_id (tags: $TAGS)"
                gh api --method DELETE "/orgs/${ORG_NAME}/packages/container/${repo}/versions/$version_id" 2>/dev/null \
                  && echo "‚úÖ Successfully deleted $version_id" \
                  || echo "‚ùå Failed to delete $version_id"
              fi
            done
            
            echo "‚úÖ Cleanup completed for $repo"
          done
          
          echo "‚úÖ Container image cleanup completed"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}