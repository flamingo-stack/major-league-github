name: Build and Deploy Major League Github on GCP 🚀 ☁️

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  PROJECT_NAME: ${{ secrets.PROJECT_NAME }}
  VERSION: v1.0.${{ github.run_number }}
  ENVIRONMENT: production
  
  # Google Tag Manager
  GTM_ID: ${{ secrets.GTM_ID }}
  
  # GCP Configuration
  GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  GKE_CLUSTER: ${{ secrets.GKE_CLUSTER }}
  GKE_ZONE: ${{ secrets.GKE_ZONE }}
  
  # GitHub Container Registry
  REGISTRY: ghcr.io
  REGISTRY_NAME: ${{ github.repository }}
  
  # Kubernetes namespace (convert repo name to valid namespace)
  NAMESPACE: ${{ github.event.repository.name }}

  DOMAIN_NAME: ${{ secrets.DOMAIN_NAME }}
  DOMAIN_SUFFIX: ${{ secrets.DOMAIN_SUFFIX }}
  STATIC_IP_NAME: "main-ingress-ip"
  STATIC_IP_ADDRESS: ${{ secrets.STATIC_IP_ADDRESS }}

  GH_API_TOKENS: ${{ secrets.GH_API_TOKENS }}
  
  # LinkedIn
  LINKEDIN_CLIENT_ID: ${{ secrets.LINKEDIN_CLIENT_ID }}
  LINKEDIN_CLIENT_SECRET: ${{ secrets.LINKEDIN_CLIENT_SECRET }}
  
  # Resource configuration
  BACKEND_REPLICAS: 1
  FRONTEND_REPLICAS: 1
  
  # Backend resources (minimal for single-node cluster)
  BACKEND_REQUEST_MEMORY: 256Mi
  BACKEND_REQUEST_CPU: 50m
  BACKEND_LIMIT_MEMORY: 1Gi
  BACKEND_LIMIT_CPU: 500m
  
  # Frontend resources (minimal for single-node cluster)
  FRONTEND_REQUEST_MEMORY: 64Mi
  FRONTEND_REQUEST_CPU: 25m
  FRONTEND_LIMIT_MEMORY: 256Mi
  FRONTEND_LIMIT_CPU: 200m
  
  # Java settings
  JAVA_MAX_HEAP: 1200m
  JAVA_MIN_HEAP: 512m
  
  # Redis Configuration
  REDIS_HOST: ${{ secrets.REDIS_IP }}

jobs:
  build-and-deploy:
    runs-on: ubuntu-22.04
    permissions:
      contents: read
      packages: write
      deployments: write

    steps:
      - name: Verify Required Secrets 🔒
        run: |
          missing_secrets=()
          
          # Core project secrets
          if [ -z "${{ secrets.PROJECT_NAME }}" ]; then
            missing_secrets+=("PROJECT_NAME")
          fi
          
          # GCP Infrastructure secrets
          if [ -z "${{ secrets.GCP_PROJECT_ID }}" ]; then
            missing_secrets+=("GCP_PROJECT_ID")
          fi
          
          if [ -z "${{ secrets.GCP_SA_KEY }}" ]; then
            missing_secrets+=("GCP_SA_KEY")
          fi
          
          if [ -z "${{ secrets.GKE_CLUSTER }}" ]; then
            missing_secrets+=("GKE_CLUSTER")
          fi
          
          if [ -z "${{ secrets.GKE_ZONE }}" ]; then
            missing_secrets+=("GKE_ZONE")
          fi
          
          # Container Registry auto-detected from repository
          
          # DNS secrets
          if [ -z "${{ secrets.DNS_PROJECT_ID }}" ]; then
            missing_secrets+=("DNS_PROJECT_ID")
          fi
          
          if [ -z "${{ secrets.DNS_ZONE }}" ]; then
            missing_secrets+=("DNS_ZONE")
          fi
          
          # Redis secret
          if [ -z "${{ secrets.REDIS_IP }}" ]; then
            missing_secrets+=("REDIS_IP")
          fi
          
          # Domain secrets
          if [ -z "${{ secrets.DOMAIN_NAME }}" ]; then
            missing_secrets+=("DOMAIN_NAME")
          fi
          
          if [ -z "${{ secrets.DOMAIN_SUFFIX }}" ]; then
            missing_secrets+=("DOMAIN_SUFFIX")
          fi
          
          # Application secrets
          if [ -z "${{ secrets.GH_API_TOKENS }}" ]; then
            missing_secrets+=("GH_API_TOKENS")
          fi
          
          if [ -z "${{ secrets.LINKEDIN_CLIENT_ID }}" ]; then
            missing_secrets+=("LINKEDIN_CLIENT_ID")
          fi
          
          if [ -z "${{ secrets.LINKEDIN_CLIENT_SECRET }}" ]; then
            missing_secrets+=("LINKEDIN_CLIENT_SECRET")
          fi
          
          if [ -z "${{ secrets.GTM_ID }}" ]; then
            missing_secrets+=("GTM_ID")
          fi
          
          if [ ${#missing_secrets[@]} -ne 0 ]; then
            echo "❌ Error: Missing required secrets: ${missing_secrets[*]}"
            exit 1
          fi
          
          echo "✅ All required secrets are set"

      - name: Checkout code 📦
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Google Cloud CLI 🛠️
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Configure gcloud 🔧
        uses: google-github-actions/setup-gcloud@v2

      - name: Get GKE credentials 🔑
        uses: google-github-actions/get-gke-credentials@v2
        with:
          cluster_name: ${{ env.GKE_CLUSTER }}
          location: ${{ env.GKE_ZONE }}

      - name: Login to GitHub Container Registry 🐳
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Check for changes 🔍
        id: changes
        run: |
          echo "🔍 Checking for changes since last successful build..."
          
          # Get the last successful workflow run SHA
          LAST_SUCCESS_SHA=$(gh run list --workflow=deploy.yml --status=success --limit=1 --json headSha --jq='.[0].headSha' || echo "")
          
          if [ -z "$LAST_SUCCESS_SHA" ] || [ "$LAST_SUCCESS_SHA" = "null" ]; then
            echo "No previous successful build found, building all images"
            echo "build_backend=true" >> $GITHUB_OUTPUT
            echo "build_cache_updater=true" >> $GITHUB_OUTPUT
            echo "build_frontend=true" >> $GITHUB_OUTPUT
          else
            echo "Comparing changes since $LAST_SUCCESS_SHA"
            
            # Check for backend changes
            if git diff --name-only $LAST_SUCCESS_SHA..HEAD | grep -E '^backend/|^kubernetes/.*backend|^\.github/workflows/deploy\.yml$' > /dev/null; then
              echo "Backend changes detected"
              echo "build_backend=true" >> $GITHUB_OUTPUT
            else
              echo "No backend changes detected"
              echo "build_backend=false" >> $GITHUB_OUTPUT
            fi
            
            # Check for cache updater changes (same as backend since it uses same source)
            if git diff --name-only $LAST_SUCCESS_SHA..HEAD | grep -E '^backend/|^kubernetes/.*cache|^\.github/workflows/deploy\.yml$' > /dev/null; then
              echo "Cache updater changes detected"
              echo "build_cache_updater=true" >> $GITHUB_OUTPUT
            else
              echo "No cache updater changes detected"
              echo "build_cache_updater=false" >> $GITHUB_OUTPUT
            fi
            
            # Check for frontend changes
            if git diff --name-only $LAST_SUCCESS_SHA..HEAD | grep -E '^frontend/|^kubernetes/.*frontend|^\.github/workflows/deploy\.yml$' > /dev/null; then
              echo "Frontend changes detected"
              echo "build_frontend=true" >> $GITHUB_OUTPUT
            else
              echo "No frontend changes detected"
              echo "build_frontend=false" >> $GITHUB_OUTPUT
            fi
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Set Webapp Environment Variables 🎨
        run: |
          # Set OG Meta Tags environment variables
          echo "OG_TITLE=Major League GitHub" >> $GITHUB_ENV
          echo "OG_DESCRIPTION=GitHub Scouting Report: Major League Edition" >> $GITHUB_ENV
          echo "OG_TYPE=website" >> $GITHUB_ENV
          echo "OG_IMAGE_URL=/og-image.png" >> $GITHUB_ENV
          echo "OG_SITE_NAME=Major League GitHub" >> $GITHUB_ENV
          
          # Set Extra Button environment variables
          echo "WEBAPP_EXTRA_BUTTON_LINK=https://medium.com/@michaelassraf/major-league-github-the-open-source-talent-leaderboard-ca2c6d7dcbeb" >> $GITHUB_ENV
          echo "WEBAPP_EXTRA_BUTTON_TEXT=Why MLG?" >> $GITHUB_ENV

      - name: Build and push backend service image 🏗️
        if: steps.changes.outputs.build_backend == 'true'
        run: |
          echo "🚀 Building backend service image..."
          docker build \
            --build-arg PROFILE=backend-service \
            -t ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/backend-service:${{ env.VERSION }} \
            -t ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/backend-service:latest \
            backend
          
          echo "🚀 Pushing backend service images..."
          docker push ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/backend-service:${{ env.VERSION }}
          docker push ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/backend-service:latest

      - name: Skip backend service build 🏗️
        if: steps.changes.outputs.build_backend == 'false'
        run: echo "⏩ Skipping backend service build - no changes detected"

      - name: Build and push cache updater image 🏗️
        if: steps.changes.outputs.build_cache_updater == 'true'
        run: |
          echo "🚀 Building cache updater image..."
          docker build \
            --build-arg PROFILE=cache-updater \
            -t ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/cache-updater:${{ env.VERSION }} \
            -t ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/cache-updater:latest \
            backend
          
          echo "🚀 Pushing cache updater images..."
          docker push ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/cache-updater:${{ env.VERSION }}
          docker push ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/cache-updater:latest

      - name: Skip cache updater build 🏗️
        if: steps.changes.outputs.build_cache_updater == 'false'
        run: echo "⏩ Skipping cache updater build - no changes detected"

      - name: Build and push frontend image 🎨
        if: steps.changes.outputs.build_frontend == 'true'
        env:
          OG_TITLE: ${{ env.OG_TITLE }}
          OG_DESCRIPTION: ${{ env.OG_DESCRIPTION }}
          OG_TYPE: ${{ env.OG_TYPE }}
          OG_IMAGE_URL: ${{ env.OG_IMAGE_URL }}
          OG_SITE_NAME: ${{ env.OG_SITE_NAME }}
          WEBAPP_EXTRA_BUTTON_LINK: ${{ env.WEBAPP_EXTRA_BUTTON_LINK }}
          WEBAPP_EXTRA_BUTTON_TEXT: ${{ env.WEBAPP_EXTRA_BUTTON_TEXT }}
        run: |
          echo "🚀 Building frontend image..."
          docker build frontend \
            --build-arg NODE_ENV=production \
            --build-arg BACKEND_API_URL="https://${{ env.DOMAIN_NAME }}.${{ env.DOMAIN_SUFFIX }}" \
            --build-arg GTM_ID="${{ env.GTM_ID }}" \
            --build-arg OG_TITLE="${{ env.OG_TITLE }}" \
            --build-arg OG_DESCRIPTION="${{ env.OG_DESCRIPTION }}" \
            --build-arg OG_TYPE="${{ env.OG_TYPE }}" \
            --build-arg OG_IMAGE_URL="${{ env.OG_IMAGE_URL }}" \
            --build-arg OG_URL="https://${{ env.DOMAIN_NAME }}.${{ env.DOMAIN_SUFFIX }}" \
            --build-arg OG_SITE_NAME="${{ env.OG_SITE_NAME }}" \
            --build-arg WEBAPP_EXTRA_BUTTON_LINK="${{ env.WEBAPP_EXTRA_BUTTON_TEXT }}" \
            --build-arg WEBAPP_EXTRA_BUTTON_TEXT="${{ env.WEBAPP_EXTRA_BUTTON_TEXT }}" \
            -t "${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/frontend:${{ env.VERSION }}" \
            -t "${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/frontend:latest"
          
          echo "🚀 Pushing frontend images..."
          docker push ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/frontend:${{ env.VERSION }}
          docker push ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/frontend:latest

      - name: Skip frontend build 🎨
        if: steps.changes.outputs.build_frontend == 'false'
        run: echo "⏩ Skipping frontend build - no changes detected"

      - name: Create Kubernetes namespace and secrets 🔐
        run: |
          # Create namespace
          kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
          
          # Create application secrets
          kubectl create secret generic app-secrets \
            --namespace=${{ env.NAMESPACE }} \
            --from-literal=github.tokens="${{ env.GH_API_TOKENS }}" \
            --from-literal=linkedin.client.id="${{ env.LINKEDIN_CLIENT_ID }}" \
            --from-literal=linkedin.client.secret="${{ env.LINKEDIN_CLIENT_SECRET }}" \
            --dry-run=client -o yaml | kubectl apply -f -
          
          echo "✅ Kubernetes secrets created successfully"

      - name: Cleanup GKE Resources 🧹
        run: |
          echo "🧹 Cleaning up all existing resources in namespace ${{ env.NAMESPACE }}..."
          
          # Clean up all resources in namespace (except secrets and configmaps we'll recreate)
          kubectl delete all --all -n ${{ env.NAMESPACE }} --ignore-not-found=true || echo "No standard resources to clean up"
          kubectl delete ingress --all -n ${{ env.NAMESPACE }} --ignore-not-found=true || echo "No ingress resources to clean up"
          kubectl delete backendconfig --all -n ${{ env.NAMESPACE }} --ignore-not-found=true || echo "No backendconfig resources to clean up"
          
          # Wait for NEG cleanup to complete (they take time to detach from load balancers)
          echo "⏳ Waiting for NEG cleanup to complete..."
          sleep 30
          
          echo "✅ Cleanup completed successfully"

      - name: Deploy to GKE 🚀
        env:
          REGISTRY_URL: ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}
          DOMAIN_SUFFIX: ${{ env.DOMAIN_SUFFIX }}
          DOMAIN_NAME: ${{ env.DOMAIN_NAME }}
          ENVIRONMENT: ${{ env.ENVIRONMENT }}
          VERSION: ${{ env.VERSION }}
          BACKEND_SERVICE_NAME: "backend-service"
          CACHE_UPDATER_NAME: "cache-updater" 
          BACKEND_SERVICE_PORT: "8080"
          CACHE_UPDATER_PORT: "8081"
          FRONTEND_PORT: "80"
          STATIC_IP_ADDRESS: ${{ secrets.STATIC_IP_ADDRESS }}
        run: |
          echo "🚀 Processing and applying Kubernetes configurations..."
          
          # Determine image versions based on what was built
          if [ "${{ steps.changes.outputs.build_backend }}" = "true" ]; then
            BACKEND_VERSION="${{ env.VERSION }}"
            echo "✅ Using new backend version: $BACKEND_VERSION"
          else
            BACKEND_VERSION="latest"
            echo "⏩ Using existing backend version: $BACKEND_VERSION"
          fi
          
          if [ "${{ steps.changes.outputs.build_cache_updater }}" = "true" ]; then
            CACHE_UPDATER_VERSION="${{ env.VERSION }}"
            echo "✅ Using new cache updater version: $CACHE_UPDATER_VERSION"
          else
            CACHE_UPDATER_VERSION="latest"
            echo "⏩ Using existing cache updater version: $CACHE_UPDATER_VERSION"
          fi
          
          if [ "${{ steps.changes.outputs.build_frontend }}" = "true" ]; then
            FRONTEND_VERSION="${{ env.VERSION }}"
            echo "✅ Using new frontend version: $FRONTEND_VERSION"
          else
            FRONTEND_VERSION="latest"
            echo "⏩ Using existing frontend version: $FRONTEND_VERSION"
          fi
          
          # Create temporary directory
          mkdir -p processed_k8s
          
          # Process config files
          echo "🚀 Processing config.yaml..."
          envsubst < kubernetes/base/config.yaml > processed_k8s/config.yaml
          kubectl apply -n ${{ env.NAMESPACE }} -f processed_k8s/config.yaml
          
          # Process and apply backend service
          echo "🚀 Processing backend service..."
          SERVICE_NAME=backend-service \
          SERVER_PORT=8080 \
          VERSION=$BACKEND_VERSION \
            envsubst < kubernetes/base/backend-service.yaml > processed_k8s/backend-service.yaml
          kubectl apply -n ${{ env.NAMESPACE }} -f processed_k8s/backend-service.yaml
          
          # Process and apply cache updater
          echo "🚀 Processing cache updater..."
          SERVICE_NAME=cache-updater \
          SERVER_PORT=8081 \
          VERSION=$CACHE_UPDATER_VERSION \
            envsubst < kubernetes/base/cache-updater-service.yaml > processed_k8s/cache-updater.yaml
          kubectl apply -n ${{ env.NAMESPACE }} -f processed_k8s/cache-updater.yaml
          
          # Process and apply frontend (creates frontend-service as ClusterIP with NEG)
          echo "🚀 Processing frontend..."
          VERSION=$FRONTEND_VERSION \
            envsubst < kubernetes/base/frontend.yaml > processed_k8s/frontend.yaml
          kubectl apply -n ${{ env.NAMESPACE }} -f processed_k8s/frontend.yaml
          echo "✅ Frontend applied successfully"
          
          echo "✅ All resources cleanup completed"
          
          # Check deployment status immediately after creation
          echo "🔍 Immediate deployment status check..."
          kubectl get deployments -n ${{ env.NAMESPACE }} -o wide
          kubectl get pods -n ${{ env.NAMESPACE }} -o wide
          kubectl get events -n ${{ env.NAMESPACE }} --sort-by='.lastTimestamp' | tail -20
          
          echo "🔍 Cache-updater specific details:"
          kubectl describe deployment/cache-updater -n ${{ env.NAMESPACE }}
          echo "🔍 Cache-updater pod details:"
          kubectl describe pods -n ${{ env.NAMESPACE }} -l app=cache-updater
          echo "🔍 Cache-updater logs (if any):"
          kubectl logs -n ${{ env.NAMESPACE }} -l app=cache-updater --tail=50 || echo "No logs yet"
          
          # Wait for deployments to be ready
          echo "🚀 Now waiting for deployments to be ready..."
          kubectl wait --for=condition=available deployment/backend-service -n ${{ env.NAMESPACE }} --timeout=300s
          kubectl wait --for=condition=available deployment/cache-updater -n ${{ env.NAMESPACE }} --timeout=300s
          kubectl wait --for=condition=available deployment/frontend -n ${{ env.NAMESPACE }} --timeout=300s
          
          # Create static IP if it doesn't exist
          echo "🚀 Ensuring static IP exists..."
          if ! gcloud compute addresses describe main-ingress-ip --global >/dev/null 2>&1; then
            echo "Creating static IP main-ingress-ip with address ${STATIC_IP_ADDRESS}..."
            gcloud compute addresses create main-ingress-ip --global --addresses=${STATIC_IP_ADDRESS}
          else
            echo "Static IP main-ingress-ip already exists"
          fi
          
          # Create ingress AFTER all services exist with static IP
          echo "🚀 Processing ingress after services are ready..."
          envsubst < kubernetes/base/ingress.yaml > processed_k8s/ingress.yaml
          kubectl apply -n ${{ env.NAMESPACE }} -f processed_k8s/ingress.yaml
          
          # Cleanup
          rm -rf processed_k8s
          
          echo "✅ Deployment completed successfully"

      - name: Verify Deployment 🔍
        run: |
          echo "🔍 Checking deployment status..."
          
          echo "Pod Status:"
          kubectl -n ${{ env.NAMESPACE }} get pods -o wide
          
          echo "Service Status:"
          kubectl -n ${{ env.NAMESPACE }} get services
          
          echo "LoadBalancer Status:"
          kubectl -n ${{ env.NAMESPACE }} get ingress main-ingress -o wide
          
          # Use static IP instead of waiting for dynamic assignment
          LB_IP="${{ env.STATIC_IP_ADDRESS }}"
          echo "✅ Using static IP: ${LB_IP}"
          echo "🌐 Frontend URL: http://${LB_IP}/"
          echo "🌐 Backend API URL: http://${LB_IP}/api/actuator/health"
          
          echo "✅ Migration Complete - Proper Kubernetes Architecture!"
          echo "🌐 Single External Gateway: http://${LB_IP}"
          echo "   - Frontend: http://${LB_IP}/"
          echo "   - API: http://${LB_IP}/api"
          echo ""
          echo "🔒 Internal Services (ClusterIP only):"
          echo "   - frontend-service:80 (internal)"
          echo "   - backend-service-service:8080 (internal)"
          echo ""
          echo "🌍 Domain: https://${{ env.DOMAIN_NAME }}.${{ env.DOMAIN_SUFFIX }}"

      - name: Update DNS Record (Cross-Project) 🌍
        run: |
          LB_IP="${{ env.STATIC_IP_ADDRESS }}"
          echo "🌍 Updating DNS record for ${{ env.DOMAIN_NAME }}.${{ env.DOMAIN_SUFFIX }} to ${LB_IP}"
          
          # DNS project details
          DNS_PROJECT_ID="${{ secrets.DNS_PROJECT_ID }}"
          DNS_ZONE="${{ secrets.DNS_ZONE }}"
          
          # Set project context to DNS project
          gcloud config set project $DNS_PROJECT_ID
          
          # Debug: List all DNS zones in the project
          echo "🔍 Available DNS zones in project $DNS_PROJECT_ID:"
          gcloud dns managed-zones list --project=$DNS_PROJECT_ID --format="table(name,dnsName)" || echo "No zones found or permission denied"
          
          echo "🔍 Looking for DNS zone: $DNS_ZONE"
          
          # Check if DNS zone exists
          if ! gcloud dns managed-zones describe $DNS_ZONE --project=$DNS_PROJECT_ID --format="value(name)" > /dev/null 2>&1; then
            echo "❌ Cloud DNS zone '$DNS_ZONE' not found in project $DNS_PROJECT_ID"
            echo "🌍 FALLBACK - Manual DNS Update Required:"
            echo "Load Balancer IP: ${LB_IP}"
            echo "Go to: https://console.cloud.google.com/net-services/dns/zones?project=$DNS_PROJECT_ID"
            exit 1
          fi
          
          # Get existing A record if it exists
          EXISTING_IP=$(gcloud dns record-sets list --zone=$DNS_ZONE --project=$DNS_PROJECT_ID --name="${{ env.DOMAIN_NAME }}.${{ env.DOMAIN_SUFFIX }}." --type=A --format="value(rrdatas[0])" 2>/dev/null | head -1 || echo "")
          
          if [ ! -z "$EXISTING_IP" ] && [ "$EXISTING_IP" != "null" ] && [ "$EXISTING_IP" != "$LB_IP" ]; then
            echo "🌍 Updating existing A record from $EXISTING_IP to $LB_IP"
            
            # Get the existing record with full details including TTL
            EXISTING_TTL=$(gcloud dns record-sets list --zone=$DNS_ZONE --project=$DNS_PROJECT_ID --name="${{ env.DOMAIN_NAME }}.${{ env.DOMAIN_SUFFIX }}." --type=A --format="value(ttl)" 2>/dev/null | head -1)
            
            if [ ! -z "$EXISTING_TTL" ] && [ "$EXISTING_TTL" != "null" ]; then
              echo "Found existing record: TTL=$EXISTING_TTL, IP=$EXISTING_IP"
              
              # Use transaction to update the record with exact existing values
              gcloud dns record-sets transaction start --zone=$DNS_ZONE --project=$DNS_PROJECT_ID
              gcloud dns record-sets transaction remove "$EXISTING_IP" \
                --name="${{ env.DOMAIN_NAME }}.${{ env.DOMAIN_SUFFIX }}." \
                --ttl=$EXISTING_TTL \
                --type=A \
                --zone=$DNS_ZONE --project=$DNS_PROJECT_ID
              gcloud dns record-sets transaction add "$LB_IP" \
                --name="${{ env.DOMAIN_NAME }}.${{ env.DOMAIN_SUFFIX }}." \
                --ttl=300 \
                --type=A \
                --zone=$DNS_ZONE --project=$DNS_PROJECT_ID
              gcloud dns record-sets transaction execute --zone=$DNS_ZONE --project=$DNS_PROJECT_ID
            else
              echo "Could not find existing record details, will create new record instead"
              # Fall back to creating new record
              gcloud dns record-sets transaction start --zone=$DNS_ZONE --project=$DNS_PROJECT_ID
              gcloud dns record-sets transaction add "$LB_IP" \
                --name="${{ env.DOMAIN_NAME }}.${{ env.DOMAIN_SUFFIX }}." \
                --ttl=300 \
                --type=A \
                --zone=$DNS_ZONE --project=$DNS_PROJECT_ID
              gcloud dns record-sets transaction execute --zone=$DNS_ZONE --project=$DNS_PROJECT_ID
            fi
            
          elif [ -z "$EXISTING_IP" ] || [ "$EXISTING_IP" = "null" ]; then
            echo "🌍 Creating new A record pointing to $LB_IP"
            
            # Create new A record
            gcloud dns record-sets transaction start --zone=$DNS_ZONE --project=$DNS_PROJECT_ID
            gcloud dns record-sets transaction add "$LB_IP" \
              --name="${{ env.DOMAIN_NAME }}.${{ env.DOMAIN_SUFFIX }}." \
              --ttl=300 \
              --type=A \
              --zone=$DNS_ZONE --project=$DNS_PROJECT_ID
            gcloud dns record-sets transaction execute --zone=$DNS_ZONE --project=$DNS_PROJECT_ID
            
          else
            echo "🌍 DNS record already points to correct IP: $LB_IP"
          fi
          
          echo "✅ DNS record updated successfully"
          echo "🌍 Domain will be accessible at: https://${{ env.DOMAIN_NAME }}.${{ env.DOMAIN_SUFFIX }}"
          echo "⏳ DNS propagation may take 5-15 minutes"
          
          # Switch back to original project
          gcloud config set project ${{ env.GCP_PROJECT_ID }}

      - name: Create GitHub Deployment 📦
        uses: chrnorm/deployment-action@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          environment: production
          initial-status: success
          environment-url: https://${{ env.DOMAIN_NAME }}.${{ env.DOMAIN_SUFFIX }}

      - name: Cleanup old container images 🧹
        if: always()
        run: |
          echo "🧹 Cleaning up old container images..."
          
          # Define image repositories
          REPOS=("backend-service" "cache-updater" "frontend")
          ORG_NAME="flamingo-stack" 
          KEEP_COUNT=3  # Keep this many most recent versioned images (plus 'latest')
          
          for repo in "${REPOS[@]}"; do
            echo "🔍 Cleaning up ${ORG_NAME}/${repo}..."
            
            # Get all versions with their metadata
            ALL_VERSIONS=$(gh api \
              "/orgs/${ORG_NAME}/packages/container/${repo}/versions" \
              --jq 'sort_by(.created_at) | reverse' 2>/dev/null || echo "[]")
            
            if [ "$ALL_VERSIONS" = "[]" ]; then
              echo "✅ No versions found for ${repo}"
              continue
            fi
            
            # Get versions to keep (latest + current + N most recent versioned)
            KEEP_LATEST=$(echo "$ALL_VERSIONS" | jq -r '.[] | select(.metadata.container.tags[] == "latest") | .id' | head -1)
            KEEP_CURRENT=$(echo "$ALL_VERSIONS" | jq -r --arg version "${{ env.VERSION }}" '.[] | select(.metadata.container.tags[] == $version) | .id' | head -1)
            
            # Get versioned images (exclude latest and current), keep only most recent N
            VERSIONED_TO_KEEP=$(echo "$ALL_VERSIONS" | jq -r --arg version "${{ env.VERSION }}" '.[] | select((.metadata.container.tags[] != "latest") and (.metadata.container.tags[] != $version)) | .id' | head -$KEEP_COUNT)
            
            # Combine all IDs to keep
            KEEP_IDS=""
            [ ! -z "$KEEP_LATEST" ] && KEEP_IDS="$KEEP_IDS $KEEP_LATEST"
            [ ! -z "$KEEP_CURRENT" ] && KEEP_IDS="$KEEP_CURRENT $KEEP_IDS"
            KEEP_IDS="$KEEP_IDS $VERSIONED_TO_KEEP"
            
            echo "📋 Will keep versions: $KEEP_IDS"
            
            # Delete versions not in keep list
            echo "$ALL_VERSIONS" | jq -r '.[] | .id' | while read version_id; do
              if echo "$KEEP_IDS" | grep -q "$version_id"; then
                TAGS=$(echo "$ALL_VERSIONS" | jq -r --arg id "$version_id" '.[] | select(.id == $id) | .metadata.container.tags[]' | tr '\n' ',' | sed 's/,$//')
                echo "⏩ Keeping version $version_id (tags: $TAGS)"
              else
                TAGS=$(echo "$ALL_VERSIONS" | jq -r --arg id "$version_id" '.[] | select(.id == $id) | .metadata.container.tags[]' | tr '\n' ',' | sed 's/,$//')
                echo "🗑️ Deleting version $version_id (tags: $TAGS)"
                gh api --method DELETE "/orgs/${ORG_NAME}/packages/container/${repo}/versions/$version_id" 2>/dev/null \
                  && echo "✅ Successfully deleted $version_id" \
                  || echo "❌ Failed to delete $version_id"
              fi
            done
            
            echo "✅ Cleanup completed for $repo"
          done
          
          echo "✅ Container image cleanup completed"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}