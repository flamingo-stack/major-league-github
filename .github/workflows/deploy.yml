name: Build and Deploy Major League Github ğŸš€ ğŸ¦©

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  REGISTRY: registry.digitalocean.com
  PROJECT_NAME: Major League Github
  REGISTRY_NAME: major-league-github
  VERSION: v1.0.${{ github.run_number }}
  DOMAIN_NAME: major-league-github
  ENVIRONMENT: production
  
  # Cluster configuration
  CLUSTER_NAME: ${{ secrets.CLUSTER_NAME }}
  CLUSTER_REGION: sfo3
  CLUSTER_SIZE: s-2vcpu-4gb
  CLUSTER_NODE_COUNT: "2"
  CLUSTER_VERSION: latest
  
  # Replica counts
  BACKEND_REPLICAS: 1
  FRONTEND_REPLICAS: 1
  
  # Backend resources
  BACKEND_REQUEST_MEMORY: 512Mi
  BACKEND_REQUEST_CPU: 200m
  BACKEND_LIMIT_MEMORY: 1Gi
  BACKEND_LIMIT_CPU: 500m
  
  # Frontend resources
  FRONTEND_REQUEST_MEMORY: 128Mi
  FRONTEND_REQUEST_CPU: 100m
  FRONTEND_LIMIT_MEMORY: 256Mi
  FRONTEND_LIMIT_CPU: 200m
  
  # Java settings
  JAVA_MAX_HEAP: 768m
  JAVA_MIN_HEAP: 512m

jobs:
  build-and-deploy:
    runs-on: ubuntu-22.04
    permissions:
      contents: read
      packages: write
      deployments: write

    steps:
      - name: Verify Required Secrets ğŸ”’
        run: |
          missing_secrets=()
          
          if [ -z "${{ secrets.CLUSTER_NAME }}" ]; then
            missing_secrets+=("CLUSTER_NAME")
          fi
          
          if [ -z "${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}" ]; then
            missing_secrets+=("DIGITALOCEAN_ACCESS_TOKEN")
          fi
          
          if [ -z "${{ secrets.GH_PAT }}" ]; then
            missing_secrets+=("GH_PAT")
          fi
          
          if [ -z "${{ secrets.GH_API_TOKENS }}" ]; then
            missing_secrets+=("GH_API_TOKENS")
          fi
          
          if [ -z "${{ secrets.DOMAIN_SUFFIX }}" ]; then
            missing_secrets+=("DOMAIN_SUFFIX")
          fi
          
          if [ ${#missing_secrets[@]} -ne 0 ]; then
            echo "âŒ Error: Missing required secrets: ${missing_secrets[*]}"
            exit 1
          fi
          
          echo "âœ… All required secrets are set"

      - name: Checkout code ğŸ“¦
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}

      - name: Install doctl ğŸ› ï¸
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

      - name: Setup DigitalOcean Infrastructure ğŸ—ï¸
        run: |
          echo "ğŸ¦© Validating DigitalOcean credentials..."
          if ! doctl account get > /dev/null 2>&1; then
            echo "âŒ Error: Invalid DigitalOcean credentials"
            exit 1
          fi
          
          echo "ğŸ¦© Creating DigitalOcean Project..."
          PROJECT_ID=""
          
          # First try to list all projects and find ours
          echo "ğŸ¦© Checking for existing project..."
          if PROJECT_ID=$(doctl projects list --format ID,Name --no-header | grep -i "${PROJECT_NAME}" | awk '{print $1}') && [ ! -z "$PROJECT_ID" ]; then
            echo "âœ… Found existing project with ID: ${PROJECT_ID}"
          else
            echo "ğŸ¦© Creating new project: ${PROJECT_NAME}..."
            if PROJECT_ID=$(doctl projects create \
              --name "${PROJECT_NAME}" \
              --purpose "Production" \
              --environment "Production" \
              --description "Major League GitHub Infrastructure" \
              --format ID --no-header); then
              echo "âœ… Project created successfully with ID: ${PROJECT_ID}"
            else
              echo "âŒ Error: Failed to create project"
              exit 1
            fi
          fi
          
          # Double check we have a valid project ID
          if [ -z "$PROJECT_ID" ] || ! doctl projects get "$PROJECT_ID" > /dev/null 2>&1; then
            echo "âŒ Error: Invalid project ID: ${PROJECT_ID}"
            exit 1
          fi
          
          echo "ğŸ¦© Project ID confirmed: ${PROJECT_ID}"
          
          echo "ğŸ¦© Checking DigitalOcean Registry..."
          if ! doctl registry get > /dev/null 2>&1; then
            echo "ğŸ¦© Creating DigitalOcean Registry..."
            if ! doctl registry create \
              --subscription-tier basic \
              --region ${CLUSTER_REGION} \
              --wait; then
              echo "âŒ Error: Failed to create registry"
              exit 1
            fi
            
            echo "ğŸ¦© Configuring registry garbage collection..."
            if ! doctl registry garbage-collection configure \
              --include-untagged-manifests \
              --exclude-tags latest \
              --keep-tags 5 \
              --schedule "0 0 * * 6" \
              --include-all-repositories \
              --wait; then
              echo "âš ï¸ Warning: Failed to configure garbage collection"
              # Don't exit on garbage collection failure, it's not critical
            fi
            
            echo "âœ… Registry created and configured successfully"
          else
            echo "âœ… Registry already exists"
          fi
          
          # Verify registry is accessible
          echo "ğŸ¦© Verifying registry access..."
          if ! doctl registry get > /dev/null 2>&1; then
            echo "âŒ Error: Registry verification failed"
            exit 1
          fi
          
          echo "ğŸ¦© Checking Kubernetes cluster..."
          if ! doctl kubernetes cluster get "${CLUSTER_NAME}" > /dev/null 2>&1; then
            echo "ğŸ¦© Creating Kubernetes cluster: ${CLUSTER_NAME}..."
            if ! doctl kubernetes cluster create "${CLUSTER_NAME}" \
              --region "${CLUSTER_REGION}" \
              --size "${CLUSTER_SIZE}" \
              --count "${CLUSTER_NODE_COUNT}" \
              --tag "${CLUSTER_NAME}" \
              --wait; then
              echo "âŒ Error: Failed to create cluster ${CLUSTER_NAME}"
              exit 1
            fi
            
            echo "ğŸ¦© Configuring cluster auto-scaling..."
            if ! doctl kubernetes cluster node-pool update "${CLUSTER_NAME}" default \
              --auto-scale \
              --min-nodes 2 \
              --max-nodes 4; then
              echo "âš ï¸ Warning: Failed to configure auto-scaling"
            fi
            
            echo "âœ… Cluster created and configured successfully"
          else
            echo "âœ… Cluster ${CLUSTER_NAME} already exists"
          fi
          
          echo "ğŸ¦© Attaching resources to project..."
          
          # Get the Kubernetes cluster ID
          CLUSTER_ID=$(doctl kubernetes cluster get "${CLUSTER_NAME}" --format ID --no-header)
          if [ ! -z "$CLUSTER_ID" ]; then
            CLUSTER_URN="do:kubernetes:${CLUSTER_ID}"
            echo "Found cluster URN: ${CLUSTER_URN}"
          else
            echo "âš ï¸ Warning: Could not get cluster ID"
          fi
          
          # Get registry ID - note that we need to extract just the ID from the registry info
          REGISTRY_INFO=$(doctl registry get --format ID --no-header)
          if [ ! -z "$REGISTRY_INFO" ]; then
            # The registry ID is the last part of the registry info
            REGISTRY_ID=$(echo "$REGISTRY_INFO" | tr -d '\r')
            REGISTRY_URN="do:registry:${REGISTRY_ID}"
            echo "Found registry URN: ${REGISTRY_URN}"
          else
            echo "âš ï¸ Warning: Could not get registry ID"
          fi
          
          # Build resources array with error checking
          RESOURCES=()
          
          # Add resources if they exist and are properly formatted
          if [ ! -z "$CLUSTER_URN" ] && [[ "$CLUSTER_URN" =~ ^do:kubernetes:[a-zA-Z0-9-]+$ ]]; then
            RESOURCES+=("${CLUSTER_URN}")
            echo "Adding cluster to resources: ${CLUSTER_URN}"
          else
            echo "âš ï¸ Warning: Invalid cluster URN format: ${CLUSTER_URN}"
          fi
          
          if [ ! -z "$REGISTRY_URN" ] && [[ "$REGISTRY_URN" =~ ^do:registry:[a-zA-Z0-9-]+$ ]]; then
            RESOURCES+=("${REGISTRY_URN}")
            echo "Adding registry to resources: ${REGISTRY_URN}"
          else
            echo "âš ï¸ Warning: Invalid registry URN format: ${REGISTRY_URN}"
          fi
          
          # Debug output
          echo "Number of resources to attach: ${#RESOURCES[@]}"
          echo "Resources array contents:"
          printf '%s\n' "${RESOURCES[@]}"
          
          # Only try to attach if we have resources
          if [ ${#RESOURCES[@]} -gt 0 ]; then
            echo "ğŸ¦© Attaching resources to project ${PROJECT_NAME} (ID: ${PROJECT_ID})..."
            
            # Build the resources string with proper quoting
            RESOURCES_STRING=""
            for resource in "${RESOURCES[@]}"; do
              RESOURCES_STRING+="--resource='${resource}' "
            done
            
            echo "Resource string for doctl: ${RESOURCES_STRING}"
            
            # Try to attach resources with full error output
            if ! eval "doctl projects resources assign '${PROJECT_ID}' ${RESOURCES_STRING}"; then
              echo "âš ï¸ Warning: Failed to attach resources to project"
              echo "ğŸ¦© Current project resources:"
              doctl projects resources list "${PROJECT_ID}" --format "Resource Type,Resource ID" --no-header || true
            else
              echo "âœ… Resources attached to project successfully"
              echo "ğŸ¦© Current project resources:"
              doctl projects resources list "${PROJECT_ID}" --format "Resource Type,Resource ID" --no-header || true
            fi
          else
            echo "âš ï¸ Warning: No valid resources to attach"
          fi
          
          # Verify project resources
          echo "ğŸ¦© Verifying project resources..."
          if ! doctl projects resources list "${PROJECT_ID}" --format "Resource Type,Resource ID" --no-header; then
            echo "âš ï¸ Warning: Could not verify project resources"
          fi
          
          echo "ğŸ¦© Verifying infrastructure..."
          if ! doctl registry get > /dev/null 2>&1; then
            echo "âŒ Error: Registry verification failed"
            exit 1
          fi
          
          if ! doctl kubernetes cluster get "${CLUSTER_NAME}" > /dev/null 2>&1; then
            echo "âŒ Error: Cluster verification failed"
            exit 1
          fi
          
          if ! doctl projects get "${PROJECT_ID}" > /dev/null 2>&1; then
            echo "âŒ Error: Project verification failed"
            exit 1
          fi
          
          echo "âœ… Infrastructure setup completed successfully"

      - name: Configure Docker and Kubernetes ğŸ”‘
        run: |
          echo "ğŸ¦© Setting up Docker..."
          if ! doctl registry login --expiry-seconds 1800; then
            echo "âŒ Error: Failed to log in to Docker registry"
            exit 1
          fi
          
          echo "ğŸ¦© Setting up Kubernetes..."
          if ! doctl kubernetes cluster kubeconfig save "$CLUSTER_NAME" --expiry-seconds 1800; then
            echo "âŒ Error: Failed to save Kubernetes config"
            exit 1
          fi
          
          echo "ğŸ¦© Verifying Kubernetes connection..."
          if ! kubectl cluster-info; then
            echo "âŒ Error: Failed to connect to Kubernetes cluster"
            exit 1
          fi
          
          echo "ğŸ¦© Creating registry credentials..."
          if ! doctl registry docker-config > docker-config.json; then
            echo "âŒ Error: Failed to get Docker config"
            exit 1
          fi
          
          DOCKER_CONFIG_BASE64=$(base64 -w 0 docker-config.json)
          echo "DOCKER_CONFIG_BASE64=${DOCKER_CONFIG_BASE64}" >> $GITHUB_ENV
          
          echo "âœ… Configuration completed successfully"

      - name: Build and push backend image ğŸ—ï¸ ğŸ¦©
        run: |
          echo "ğŸ¦© Building backend image..."
          if ! docker build -t ${REGISTRY}/${REGISTRY_NAME}/backend:${VERSION} ./backend; then
            echo "âŒ Error: Failed to build backend image"
            exit 1
          fi
          
          echo "ğŸ¦© Pushing versioned backend image..."
          if ! docker push ${REGISTRY}/${REGISTRY_NAME}/backend:${VERSION}; then
            echo "âŒ Error: Failed to push backend versioned image"
            exit 1
          fi
          
          echo "ğŸ¦© Tagging and pushing latest..."
          docker tag ${REGISTRY}/${REGISTRY_NAME}/backend:${VERSION} ${REGISTRY}/${REGISTRY_NAME}/backend:latest
          if ! docker push ${REGISTRY}/${REGISTRY_NAME}/backend:latest; then
            echo "âŒ Error: Failed to push backend latest image"
            exit 1
          fi
          
          echo "âœ… Backend image build and push completed"

      - name: Build and push frontend image ğŸ¨ ğŸ¦©
        run: |
          echo "ğŸ¦© Building frontend image..."
          if ! docker build -t ${REGISTRY}/${REGISTRY_NAME}/frontend:${VERSION} ./frontend; then
            echo "âŒ Error: Failed to build frontend image"
            exit 1
          fi
          
          echo "ğŸ¦© Pushing versioned frontend image..."
          if ! docker push ${REGISTRY}/${REGISTRY_NAME}/frontend:${VERSION}; then
            echo "âŒ Error: Failed to push frontend versioned image"
            exit 1
          fi
          
          echo "ğŸ¦© Tagging and pushing latest..."
          docker tag ${REGISTRY}/${REGISTRY_NAME}/frontend:${VERSION} ${REGISTRY}/${REGISTRY_NAME}/frontend:latest
          if ! docker push ${REGISTRY}/${REGISTRY_NAME}/frontend:latest; then
            echo "âŒ Error: Failed to push frontend latest image"
            exit 1
          fi
          
          echo "âœ… Frontend image build and push completed"

      - name: Cleanup old images ğŸ§¹ ğŸ¦©
        run: |
          echo "ğŸ¦© Cleaning up old images..."
          if ! ./.github/scripts/cleanup-registry.sh; then
            echo "âš ï¸ Warning: Image cleanup had some issues"
          fi
          echo "âœ… Image cleanup completed"

      - name: Setup Kubernetes Dependencies ğŸ¯ ğŸ¦©
        run: |
          echo "ğŸ¦© Installing Helm..."
          curl -fsSL https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3 | bash
          
          echo "ğŸ¦© Adding Helm repositories..."
          helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
          helm repo update
          
          # Function to retry commands
          retry_command() {
            local -r cmd="${1}"
            local -r description="${2}"
            local -r max_attempts=3
            local -r sleep_time=30
            
            for ((i = 1; i <= max_attempts; i++)); do
              echo "ğŸ¦© Attempt $i/$max_attempts: $description"
              if eval "$cmd"; then
                echo "âœ… $description successful"
                return 0
              else
                echo "âš ï¸ Attempt $i failed"
                if [ $i -lt $max_attempts ]; then
                  echo "ğŸ¦© Waiting ${sleep_time}s before retrying..."
                  sleep $sleep_time
                  
                  echo "ğŸ¦© Verifying Kubernetes connection..."
                  kubectl cluster-info
                  
                  echo "ğŸ¦© Refreshing Kubernetes credentials..."
                  doctl kubernetes cluster kubeconfig save "$CLUSTER_NAME" --expiry-seconds 3600
                fi
              fi
            done
            
            echo "âŒ Error: $description failed after $max_attempts attempts"
            return 1
          }
          
          echo "ğŸ¦© Installing NGINX Ingress Controller..."
          NGINX_CMD="helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx \
            --namespace ingress-nginx --create-namespace \
            --set controller.publishService.enabled=true \
            --set controller.service.type=LoadBalancer \
            --set controller.service.annotations.\"service\\.beta\\.kubernetes\\.io/do-loadbalancer-name\"=\"${DOMAIN_NAME}-lb\" \
            --set controller.service.annotations.\"service\\.beta\\.kubernetes\\.io/do-loadbalancer-enable-proxy-protocol\"=true \
            --set controller.service.annotations.\"service\\.beta\\.kubernetes\\.io/do-loadbalancer-hostname\"=\"${DOMAIN_NAME}.${DOMAIN_SUFFIX}\" \
            --set controller.service.annotations.\"service\\.beta\\.kubernetes\\.io/do-loadbalancer-redirect-http-to-https\"=true \
            --set controller.service.annotations.\"service\\.beta\\.kubernetes\\.io/do-loadbalancer-protocol\"=tcp \
            --set controller.service.annotations.\"service\\.beta\\.kubernetes\\.io/do-loadbalancer-tls-passthrough\"=true \
            --set controller.service.annotations.\"service\\.beta\\.kubernetes\\.io/do-loadbalancer-size-unit\"=1 \
            --set controller.service.annotations.\"service\\.beta\\.kubernetes\\.io/do-loadbalancer-size-unit-type\"=basic \
            --set admissionWebhooks.enabled=false \
            --wait --timeout 5m"
          
          if ! retry_command "$NGINX_CMD" "Install NGINX Ingress Controller"; then
            echo "âŒ Error: Failed to install NGINX Ingress"
            kubectl get pods -n ingress-nginx
            kubectl describe pods -n ingress-nginx
            exit 1
          fi

          # Wait for ingress controller to be fully ready
          echo "ğŸ¦© Waiting for Ingress Controller to be ready..."
          kubectl wait --namespace ingress-nginx \
            --for=condition=ready pod \
            --selector=app.kubernetes.io/component=controller \
            --timeout=5m

          echo "ğŸ¦© Creating namespace if not exists..."
          if ! kubectl create namespace ${REGISTRY_NAME} --dry-run=client -o yaml | kubectl apply -f -; then
            echo "âŒ Error: Failed to create namespace"
            exit 1
          fi

      - name: Create Kubernetes Secrets ğŸ¦©
        run: |
          echo "ğŸ¦© Creating namespace if not exists..."
          if ! kubectl create namespace ${REGISTRY_NAME} --dry-run=client -o yaml | kubectl apply -f -; then
            echo "âŒ Error: Failed to create namespace"
            exit 1
          fi
          
          echo "ğŸ¦© Creating registry credentials..."
          if ! kubectl create secret docker-registry registry-credentials \
            --namespace=${REGISTRY_NAME} \
            --docker-server=${REGISTRY} \
            --docker-username=${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }} \
            --docker-password=${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }} \
            --dry-run=client -o yaml | kubectl apply -f -; then
            echo "âŒ Error: Failed to create registry credentials"
            exit 1
          fi
          
          echo "ğŸ¦© Creating application secrets..."
          # Create a temporary file for the tokens
          echo "${{ secrets.GH_API_TOKENS }}" > github_tokens.txt
          
          # Delete existing secret if it exists
          kubectl delete secret app-secrets --namespace=${REGISTRY_NAME} --ignore-not-found=true
          
          # Create the secret with the correct key
          if ! kubectl create secret generic app-secrets \
            --namespace=${REGISTRY_NAME} \
            --from-literal=github.tokens="${{ secrets.GH_API_TOKENS }}"; then
            echo "âŒ Error: Failed to create application secrets"
            exit 1
          fi
          
          # Verify secret was created correctly
          echo "ğŸ¦© Verifying secret creation..."
          if ! kubectl get secret app-secrets --namespace=${REGISTRY_NAME} -o jsonpath='{.data}' | grep 'github\.tokens'; then
            echo "âŒ Error: Secret verification failed"
            exit 1
          fi
          
          echo "âœ… Kubernetes secrets created successfully"

      - name: Deploy Kubernetes Configurations ğŸš€ ğŸ¦©
        env:
          REGISTRY_URL: ${REGISTRY}/${REGISTRY_NAME}
          DOMAIN_SUFFIX: ${{ secrets.DOMAIN_SUFFIX }}
        run: |
          echo "ğŸ¦© Processing and applying Kubernetes configurations..."
          
          for file in kubernetes/base/*.yaml; do
            echo "ğŸ¦© Processing $file..."
            if ! envsubst < $file | kubectl apply -n ${REGISTRY_NAME} -f -; then
              echo "âŒ Error: Failed to apply $file"
              exit 1
            fi
          done
          
          echo "ğŸ¦© Waiting for deployments to be ready..."
          
          # Function to check pod status and logs
          check_deployment() {
            local deployment=$1
            echo "ğŸ¦© Checking status for deployment: $deployment"
            
            # Get pod status
            echo "ğŸ¦© Pod status:"
            kubectl -n ${REGISTRY_NAME} get pods -l app=$deployment -o wide
            
            # Get failed pods if any
            failed_pods=$(kubectl -n ${REGISTRY_NAME} get pods -l app=$deployment -o jsonpath='{.items[?(@.status.phase!="Running")].metadata.name}')
            
            if [ ! -z "$failed_pods" ]; then
              echo "ğŸ¦© Found failed pods: $failed_pods"
              for pod in $failed_pods; do
                echo "ğŸ¦© Logs for failed pod $pod:"
                kubectl -n ${REGISTRY_NAME} logs $pod --all-containers --tail=50
                
                echo "ğŸ¦© Events for failed pod $pod:"
                kubectl -n ${REGISTRY_NAME} get events --field-selector involvedObject.name=$pod
                
                echo "ğŸ¦© Describing failed pod $pod:"
                kubectl -n ${REGISTRY_NAME} describe pod $pod
              done
            fi
          }
          
          # Wait for backend deployment
          echo "ğŸ¦© Waiting for backend deployment..."
          if ! kubectl -n ${REGISTRY_NAME} rollout status deployment/backend --timeout=5m; then
            echo "âŒ Error: Backend deployment failed to roll out"
            check_deployment "backend"
            exit 1
          fi
          
          # Wait for frontend deployment
          echo "ğŸ¦© Waiting for frontend deployment..."
          if ! kubectl -n ${REGISTRY_NAME} rollout status deployment/frontend --timeout=5m; then
            echo "âŒ Error: Frontend deployment failed to roll out"
            check_deployment "frontend"
            exit 1
          fi
          
          echo "âœ… Kubernetes configurations deployed successfully"

      - name: Update DNS Records ğŸŒ ğŸ¦©
        run: |
          echo "ğŸ¦© Getting LoadBalancer IP..."
          LB_IP=""
          RETRY_COUNT=0
          MAX_RETRIES=30
          
          while [ -z "$LB_IP" ] && [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            LB_IP=$(kubectl -n ingress-nginx get service ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
            if [ -z "$LB_IP" ]; then
              echo "ğŸ¦© Waiting for LoadBalancer IP... (Attempt $((RETRY_COUNT + 1))/$MAX_RETRIES)"
              sleep 10
              RETRY_COUNT=$((RETRY_COUNT + 1))
            fi
          done
          
          if [ -z "$LB_IP" ]; then
            echo "âŒ Error: Failed to get LoadBalancer IP after $MAX_RETRIES attempts"
            exit 1
          fi
          
          echo "ğŸ¦© Finding existing DNS records..."
          EXISTING_RECORDS=$(doctl compute domain records list ${{ secrets.DOMAIN_SUFFIX }} --format ID,Type,Name --no-header | grep "^[0-9]* *A *${{ env.DOMAIN_NAME }}" || true)
          
          if [ ! -z "$EXISTING_RECORDS" ]; then
            echo "ğŸ¦© Found existing records to delete:"
            echo "$EXISTING_RECORDS"
            
            echo "ğŸ¦© Deleting existing records..."
            while IFS= read -r record; do
              RECORD_ID=$(echo $record | awk '{print $1}')
              echo "ğŸ¦© Deleting record ID: $RECORD_ID"
              if ! doctl compute domain records delete ${{ secrets.DOMAIN_SUFFIX }} $RECORD_ID --force; then
                echo "âš ï¸ Warning: Failed to delete record $RECORD_ID"
              fi
            done <<< "$EXISTING_RECORDS"
          else
            echo "ğŸ¦© No existing records found"
          fi
          
          echo "ğŸ¦© Creating new DNS A record..."
          if ! doctl compute domain records create ${{ secrets.DOMAIN_SUFFIX }} \
            --record-type A \
            --record-name "${{ env.DOMAIN_NAME }}" \
            --record-data "${LB_IP}" \
            --record-ttl 300; then
            echo "âŒ Error: Failed to create DNS record"
            exit 1
          fi
          
          echo "âœ… DNS records updated successfully"

      - name: Verify Deployment ğŸ” ğŸ¦©
        run: |
          echo "ğŸ¦© Checking deployment status..."
          
          echo "ğŸ¦© Pod Status:"
          kubectl -n ${REGISTRY_NAME} get pods -o wide
          
          echo "ğŸ¦© Service Status:"
          kubectl -n ${REGISTRY_NAME} get services
          
          echo "ğŸ¦© Ingress Status:"
          kubectl -n ${REGISTRY_NAME} get ingress
          
          echo "ğŸ¦© Certificate Status:"
          kubectl -n ${REGISTRY_NAME} get certificates
          
          echo "ğŸ¦© Events:"
          kubectl -n ${REGISTRY_NAME} get events --sort-by='.lastTimestamp'
          
          # Verify all pods are running
          failed_pods=$(kubectl -n ${REGISTRY_NAME} get pods -o jsonpath='{.items[?(@.status.phase!="Running")].metadata.name}')
          if [ ! -z "$failed_pods" ]; then
            echo "âŒ Error: The following pods are not running:"
            echo "$failed_pods"
            
            for pod in $failed_pods; do
              echo "ğŸ¦© Describing failed pod $pod:"
              kubectl -n ${REGISTRY_NAME} describe pod $pod
              
              echo "ğŸ¦© Logs for failed pod $pod:"
              kubectl -n ${REGISTRY_NAME} logs $pod --all-containers --tail=50 || true
            done
            exit 1
          fi
          
          echo "âœ… Deployment verification completed"

      - name: Create GitHub Deployment ğŸ“¦ ğŸ¦©
        uses: chrnorm/deployment-action@v2
        with:
          token: ${{ secrets.GH_PAT }}
          environment: production
          initial-status: success
          environment-url: https://${{ env.DOMAIN_NAME }}.${{ secrets.DOMAIN_SUFFIX }}

      - name: Set environment variables
        run: |
          echo "DOMAIN_NAME=major-league-github" >> $GITHUB_ENV
          echo "ENVIRONMENT=production" >> $GITHUB_ENV
          echo "BACKEND_REPLICAS=2" >> $GITHUB_ENV
          echo "FRONTEND_REPLICAS=2" >> $GITHUB_ENV
          # Reduced resource requests and limits
          echo "BACKEND_REQUEST_MEMORY=512Mi" >> $GITHUB_ENV
          echo "BACKEND_REQUEST_CPU=200m" >> $GITHUB_ENV
          echo "BACKEND_LIMIT_MEMORY=1Gi" >> $GITHUB_ENV
          echo "BACKEND_LIMIT_CPU=500m" >> $GITHUB_ENV
          echo "FRONTEND_REQUEST_MEMORY=128Mi" >> $GITHUB_ENV
          echo "FRONTEND_REQUEST_CPU=100m" >> $GITHUB_ENV
          echo "FRONTEND_LIMIT_MEMORY=256Mi" >> $GITHUB_ENV
          echo "FRONTEND_LIMIT_CPU=200m" >> $GITHUB_ENV
          echo "JAVA_MAX_HEAP=768m" >> $GITHUB_ENV
          echo "JAVA_MIN_HEAP=512m" >> $GITHUB_ENV


