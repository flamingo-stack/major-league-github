name: Build and Deploy Major League Github üöÄ ü¶©

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  REGISTRY: registry.digitalocean.com
  PROJECT_NAME: Major League Github
  REGISTRY_NAME: major-league-github
  VERSION: v1.0.${{ github.run_number }}
  DOMAIN_NAME: major-league-github
  ENVIRONMENT: production
  
  # Cluster configuration
  CLUSTER_NAME: ${{ secrets.CLUSTER_NAME }}
  CLUSTER_REGION: sfo3
  CLUSTER_SIZE: s-2vcpu-4gb
  CLUSTER_NODE_COUNT: "2"
  CLUSTER_VERSION: latest
  
  # Replica counts
  BACKEND_REPLICAS: 1
  FRONTEND_REPLICAS: 1
  
  # Backend resources
  BACKEND_REQUEST_MEMORY: 512Mi
  BACKEND_REQUEST_CPU: 200m
  BACKEND_LIMIT_MEMORY: 1Gi
  BACKEND_LIMIT_CPU: 500m
  
  # Frontend resources
  FRONTEND_REQUEST_MEMORY: 128Mi
  FRONTEND_REQUEST_CPU: 100m
  FRONTEND_LIMIT_MEMORY: 256Mi
  FRONTEND_LIMIT_CPU: 200m
  
  # Java settings
  JAVA_MAX_HEAP: 768m
  JAVA_MIN_HEAP: 512m

jobs:
  build-and-deploy:
    runs-on: ubuntu-22.04
    permissions:
      contents: read
      packages: write
      deployments: write

    steps:
      - name: Verify Required Secrets üîí
        run: |
          missing_secrets=()
          
          if [ -z "${{ secrets.CLUSTER_NAME }}" ]; then
            missing_secrets+=("CLUSTER_NAME")
          fi
          
          if [ -z "${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}" ]; then
            missing_secrets+=("DIGITALOCEAN_ACCESS_TOKEN")
          fi
          
          if [ -z "${{ secrets.GH_PAT }}" ]; then
            missing_secrets+=("GH_PAT")
          fi
          
          if [ -z "${{ secrets.GH_API_TOKENS }}" ]; then
            missing_secrets+=("GH_API_TOKENS")
          fi
          
          if [ -z "${{ secrets.LETSENCRYPT_EMAIL }}" ]; then
            missing_secrets+=("LETSENCRYPT_EMAIL")
          fi
          
          if [ -z "${{ secrets.DOMAIN_SUFFIX }}" ]; then
            missing_secrets+=("DOMAIN_SUFFIX")
          fi
          
          if [ ${#missing_secrets[@]} -ne 0 ]; then
            echo "‚ùå Error: The following required secrets are missing:"
            printf '%s\n' "${missing_secrets[@]}"
            echo ""
            echo "Please add these secrets in your GitHub repository:"
            echo "1. Go to Settings ‚Üí Secrets and variables ‚Üí Actions"
            echo "2. Click on 'New repository secret'"
            echo "3. Add each missing secret with its value"
            echo ""
            echo "Required secrets and their purposes:"
            echo "- CLUSTER_NAME: Your DigitalOcean Kubernetes cluster name"
            echo "- DIGITALOCEAN_ACCESS_TOKEN: Your DigitalOcean API token"
            echo "- GH_PAT: GitHub Personal Access Token"
            echo "- GH_API_TOKENS: GitHub API tokens for the application"
            echo "- LETSENCRYPT_EMAIL: Email for SSL certificates"
            echo "- DOMAIN_SUFFIX: Domain suffix (e.g., 'flamingo.cx')"
            exit 1
          fi
          
          echo "‚úÖ All required secrets are set"

      - name: Checkout code üì¶
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}

      - name: Install doctl üõ†Ô∏è
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

      - name: Setup DigitalOcean Infrastructure üèóÔ∏è
        run: |
          echo "ü¶© Validating DigitalOcean credentials..."
          if ! doctl account get > /dev/null 2>&1; then
            echo "‚ùå Error: Invalid DigitalOcean credentials"
            exit 1
          fi
          
          echo "ü¶© Creating DigitalOcean Project..."
          PROJECT_ID=""
          PROJECT_NAME_CLEAN="major-league-github"  # Clean name without spaces
          
          # First try to list all projects and find ours
          echo "ü¶© Checking for existing project..."
          if PROJECT_ID=$(doctl projects list --format ID,Name --no-header | grep -i "${PROJECT_NAME_CLEAN}" | awk '{print $1}') && [ ! -z "$PROJECT_ID" ]; then
            echo "‚úÖ Found existing project with ID: ${PROJECT_ID}"
          else
            echo "ü¶© Creating new project: ${PROJECT_NAME_CLEAN}..."
            if PROJECT_ID=$(doctl projects create \
              --name "${PROJECT_NAME_CLEAN}" \
              --purpose "Production" \
              --environment "Production" \
              --description "Major League GitHub Infrastructure" \
              --format ID --no-header); then
              echo "‚úÖ Project created successfully with ID: ${PROJECT_ID}"
            else
              echo "‚ùå Error: Failed to create project"
              exit 1
            fi
          fi
          
          # Double check we have a valid project ID
          if [ -z "$PROJECT_ID" ] || ! doctl projects get "$PROJECT_ID" > /dev/null 2>&1; then
            echo "‚ùå Error: Invalid project ID: ${PROJECT_ID}"
            exit 1
          fi
          
          echo "ü¶© Project ID confirmed: ${PROJECT_ID}"
          
          echo "ü¶© Checking DigitalOcean Registry..."
          if ! doctl registry get > /dev/null 2>&1; then
            echo "ü¶© Creating DigitalOcean Registry..."
            if ! doctl registry create \
              --subscription-tier basic \
              --region ${CLUSTER_REGION} \
              --wait; then
              echo "‚ùå Error: Failed to create registry"
              exit 1
            fi
            
            echo "ü¶© Configuring registry garbage collection..."
            if ! doctl registry garbage-collection configure \
              --include-untagged-manifests \
              --exclude-tags latest \
              --keep-tags 5 \
              --schedule "0 0 * * 6" \
              --include-all-repositories \
              --wait; then
              echo "‚ö†Ô∏è Warning: Failed to configure garbage collection"
              # Don't exit on garbage collection failure, it's not critical
            fi
            
            echo "‚úÖ Registry created and configured successfully"
          else
            echo "‚úÖ Registry already exists"
          fi
          
          # Verify registry is accessible
          echo "ü¶© Verifying registry access..."
          if ! doctl registry get > /dev/null 2>&1; then
            echo "‚ùå Error: Registry verification failed"
            exit 1
          fi
          
          echo "ü¶© Checking Kubernetes cluster..."
          if ! doctl kubernetes cluster get "${CLUSTER_NAME}" > /dev/null 2>&1; then
            echo "ü¶© Creating Kubernetes cluster: ${CLUSTER_NAME}..."
            if ! doctl kubernetes cluster create "${CLUSTER_NAME}" \
              --region "${CLUSTER_REGION}" \
              --size "${CLUSTER_SIZE}" \
              --count "${CLUSTER_NODE_COUNT}" \
              --tag "${CLUSTER_NAME}" \
              --wait; then
              echo "‚ùå Error: Failed to create cluster ${CLUSTER_NAME}"
              exit 1
            fi
            
            echo "ü¶© Configuring cluster auto-scaling..."
            if ! doctl kubernetes cluster node-pool update "${CLUSTER_NAME}" default \
              --auto-scale \
              --min-nodes 2 \
              --max-nodes 4; then
              echo "‚ö†Ô∏è Warning: Failed to configure auto-scaling"
            fi
            
            echo "‚úÖ Cluster created and configured successfully"
          else
            echo "‚úÖ Cluster ${CLUSTER_NAME} already exists"
          fi
          
          echo "ü¶© Attaching resources to project..."
          
          # Get the Kubernetes cluster ID
          CLUSTER_ID=$(doctl kubernetes cluster get "${CLUSTER_NAME}" --format ID --no-header)
          if [ ! -z "$CLUSTER_ID" ]; then
            CLUSTER_URN="do:kubernetes:${CLUSTER_ID}"
            echo "Found cluster URN: ${CLUSTER_URN}"
          else
            echo "‚ö†Ô∏è Warning: Could not get cluster ID"
          fi
          
          # Get registry ID - note that we need to extract just the ID from the registry info
          REGISTRY_INFO=$(doctl registry get --format ID --no-header)
          if [ ! -z "$REGISTRY_INFO" ]; then
            # The registry ID is the last part of the registry info
            REGISTRY_ID=$(echo "$REGISTRY_INFO" | tr -d '\r')
            REGISTRY_URN="do:registry:${REGISTRY_ID}"
            echo "Found registry URN: ${REGISTRY_URN}"
          else
            echo "‚ö†Ô∏è Warning: Could not get registry ID"
          fi
          
          # Build resources array with error checking
          RESOURCES=()
          
          # Add resources if they exist and are properly formatted
          if [ ! -z "$CLUSTER_URN" ] && [[ "$CLUSTER_URN" =~ ^do:kubernetes:[a-zA-Z0-9-]+$ ]]; then
            RESOURCES+=("${CLUSTER_URN}")
            echo "Adding cluster to resources: ${CLUSTER_URN}"
          else
            echo "‚ö†Ô∏è Warning: Invalid cluster URN format: ${CLUSTER_URN}"
          fi
          
          if [ ! -z "$REGISTRY_URN" ] && [[ "$REGISTRY_URN" =~ ^do:registry:[a-zA-Z0-9-]+$ ]]; then
            RESOURCES+=("${REGISTRY_URN}")
            echo "Adding registry to resources: ${REGISTRY_URN}"
          else
            echo "‚ö†Ô∏è Warning: Invalid registry URN format: ${REGISTRY_URN}"
          fi
          
          # Debug output
          echo "Number of resources to attach: ${#RESOURCES[@]}"
          echo "Resources array contents:"
          printf '%s\n' "${RESOURCES[@]}"
          
          # Only try to attach if we have resources
          if [ ${#RESOURCES[@]} -gt 0 ]; then
            echo "ü¶© Attaching resources to project ${PROJECT_NAME} (ID: ${PROJECT_ID})..."
            
            # Build the resources string with proper quoting
            RESOURCES_STRING=""
            for resource in "${RESOURCES[@]}"; do
              RESOURCES_STRING+="--resource='${resource}' "
            done
            
            echo "Resource string for doctl: ${RESOURCES_STRING}"
            
            # Try to attach resources with full error output
            if ! eval "doctl projects resources assign '${PROJECT_ID}' ${RESOURCES_STRING}"; then
              echo "‚ö†Ô∏è Warning: Failed to attach resources to project"
              echo "ü¶© Current project resources:"
              doctl projects resources list "${PROJECT_ID}" --format "Resource Type,Resource ID" --no-header || true
            else
              echo "‚úÖ Resources attached to project successfully"
              echo "ü¶© Current project resources:"
              doctl projects resources list "${PROJECT_ID}" --format "Resource Type,Resource ID" --no-header || true
            fi
          else
            echo "‚ö†Ô∏è Warning: No valid resources to attach"
          fi
          
          # Verify project resources
          echo "ü¶© Verifying project resources..."
          if ! doctl projects resources list "${PROJECT_ID}" --format "Resource Type,Resource ID" --no-header; then
            echo "‚ö†Ô∏è Warning: Could not verify project resources"
          fi
          
          echo "ü¶© Verifying infrastructure..."
          if ! doctl registry get > /dev/null 2>&1; then
            echo "‚ùå Error: Registry verification failed"
            exit 1
          fi
          
          if ! doctl kubernetes cluster get "${CLUSTER_NAME}" > /dev/null 2>&1; then
            echo "‚ùå Error: Cluster verification failed"
            exit 1
          fi
          
          if ! doctl projects get "${PROJECT_ID}" > /dev/null 2>&1; then
            echo "‚ùå Error: Project verification failed"
            exit 1
          fi
          
          echo "‚úÖ Infrastructure setup completed successfully"

      - name: Configure Docker and Kubernetes üîë
        run: |
          echo "ü¶© Setting up Docker..."
          if ! doctl registry login --expiry-seconds 1800; then
            echo "‚ùå Error: Failed to log in to Docker registry"
            exit 1
          fi
          
          echo "ü¶© Setting up Kubernetes..."
          if ! doctl kubernetes cluster kubeconfig save "$CLUSTER_NAME" --expiry-seconds 1800; then
            echo "‚ùå Error: Failed to save Kubernetes config"
            exit 1
          fi
          
          echo "ü¶© Verifying Kubernetes connection..."
          if ! kubectl cluster-info; then
            echo "‚ùå Error: Failed to connect to Kubernetes cluster"
            exit 1
          fi
          
          echo "ü¶© Creating registry credentials..."
          if ! doctl registry docker-config > docker-config.json; then
            echo "‚ùå Error: Failed to get Docker config"
            exit 1
          fi
          
          DOCKER_CONFIG_BASE64=$(base64 -w 0 docker-config.json)
          echo "DOCKER_CONFIG_BASE64=${DOCKER_CONFIG_BASE64}" >> $GITHUB_ENV
          
          echo "‚úÖ Configuration completed successfully"

      - name: Build and push backend image üèóÔ∏è ü¶©
        run: |
          echo "ü¶© Building backend image..."
          if ! docker build -t ${REGISTRY}/${REGISTRY_NAME}/backend:${VERSION} ./backend; then
            echo "‚ùå Error: Failed to build backend image"
            exit 1
          fi
          
          echo "ü¶© Pushing versioned backend image..."
          if ! docker push ${REGISTRY}/${REGISTRY_NAME}/backend:${VERSION}; then
            echo "‚ùå Error: Failed to push backend versioned image"
            exit 1
          fi
          
          echo "ü¶© Tagging and pushing latest..."
          docker tag ${REGISTRY}/${REGISTRY_NAME}/backend:${VERSION} ${REGISTRY}/${REGISTRY_NAME}/backend:latest
          if ! docker push ${REGISTRY}/${REGISTRY_NAME}/backend:latest; then
            echo "‚ùå Error: Failed to push backend latest image"
            exit 1
          fi
          
          echo "‚úÖ Backend image build and push completed"

      - name: Build and push frontend image üé® ü¶©
        run: |
          echo "ü¶© Building frontend image..."
          if ! docker build -t ${REGISTRY}/${REGISTRY_NAME}/frontend:${VERSION} ./frontend; then
            echo "‚ùå Error: Failed to build frontend image"
            exit 1
          fi
          
          echo "ü¶© Pushing versioned frontend image..."
          if ! docker push ${REGISTRY}/${REGISTRY_NAME}/frontend:${VERSION}; then
            echo "‚ùå Error: Failed to push frontend versioned image"
            exit 1
          fi
          
          echo "ü¶© Tagging and pushing latest..."
          docker tag ${REGISTRY}/${REGISTRY_NAME}/frontend:${VERSION} ${REGISTRY}/${REGISTRY_NAME}/frontend:latest
          if ! docker push ${REGISTRY}/${REGISTRY_NAME}/frontend:latest; then
            echo "‚ùå Error: Failed to push frontend latest image"
            exit 1
          fi
          
          echo "‚úÖ Frontend image build and push completed"

      - name: Setup Kubernetes Dependencies üéØ ü¶©
        run: |
          echo "ü¶© Installing Helm..."
          if ! curl -fsSL https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3 | bash; then
            echo "‚ùå Error: Failed to install Helm"
            exit 1
          fi
          
          echo "ü¶© Adding Helm repositories..."
          helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
          helm repo add jetstack https://charts.jetstack.io
          helm repo update
          
          # Function to retry commands
          retry_command() {
            local -r cmd="${1}"
            local -r description="${2}"
            local -r max_attempts=3
            local -r sleep_time=30
            
            for ((i = 1; i <= max_attempts; i++)); do
              echo "ü¶© Attempt $i/$max_attempts: $description"
              if eval "$cmd"; then
                echo "‚úÖ $description successful"
                return 0
              else
                echo "‚ö†Ô∏è Attempt $i failed"
                if [ $i -lt $max_attempts ]; then
                  echo "ü¶© Waiting ${sleep_time}s before retrying..."
                  sleep $sleep_time
                  
                  echo "ü¶© Verifying Kubernetes connection..."
                  kubectl cluster-info
                  
                  echo "ü¶© Refreshing Kubernetes credentials..."
                  doctl kubernetes cluster kubeconfig save "$CLUSTER_NAME" --expiry-seconds 3600
                fi
              fi
            done
            
            echo "‚ùå Error: $description failed after $max_attempts attempts"
            return 1
          }
          
          echo "ü¶© Installing NGINX Ingress Controller..."
          NGINX_CMD="helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx \
            --namespace ingress-nginx --create-namespace \
            --set controller.publishService.enabled=true \
            --wait --timeout 5m"
          
          if ! retry_command "$NGINX_CMD" "Install NGINX Ingress Controller"; then
            echo "‚ùå Error: Failed to install NGINX Ingress"
            kubectl get pods -n ingress-nginx
            kubectl describe pods -n ingress-nginx
            exit 1
          fi
          
          echo "ü¶© Installing cert-manager..."
          
          # Function to check for ongoing Helm operations
          check_helm_operations() {
            local namespace=$1
            if kubectl get pods -n $namespace 2>/dev/null | grep -q "helm-install"; then
              return 1
            fi
            return 0
          }
          
          # Clean up any existing cert-manager installation
          echo "ü¶© Cleaning up existing cert-manager resources..."
          kubectl delete --ignore-not-found=true -f https://github.com/cert-manager/cert-manager/releases/latest/download/cert-manager.crds.yaml
          
          # Delete the namespace if it exists (this will remove all resources including Helm releases)
          echo "ü¶© Removing existing cert-manager namespace if it exists..."
          kubectl delete namespace cert-manager --ignore-not-found=true
          
          # Wait for namespace deletion to complete
          echo "ü¶© Waiting for cert-manager namespace cleanup..."
          while kubectl get namespace cert-manager 2>/dev/null; do
            echo "ü¶© Waiting for namespace deletion..."
            sleep 5
          done
          
          # Helm release cleanup
          echo "ü¶© Cleaning up Helm release..."
          helm delete cert-manager --namespace cert-manager --ignore-not-found
          
          # Wait for any ongoing Helm operations to complete
          echo "ü¶© Waiting for any ongoing Helm operations..."
          WAIT_SECONDS=0
          MAX_WAIT=120
          while ! check_helm_operations "cert-manager" && [ $WAIT_SECONDS -lt $MAX_WAIT ]; do
            echo "ü¶© Waiting for Helm operations to complete... ($WAIT_SECONDS/$MAX_WAIT seconds)"
            sleep 5
            WAIT_SECONDS=$((WAIT_SECONDS + 5))
          done
          
          if [ $WAIT_SECONDS -ge $MAX_WAIT ]; then
            echo "‚ùå Error: Timeout waiting for Helm operations to complete"
            exit 1
          fi
          
          # Install cert-manager with retries
          CERT_MANAGER_CMD="helm upgrade --install cert-manager jetstack/cert-manager \
            --namespace cert-manager --create-namespace \
            --set installCRDs=true \
            --wait --timeout 5m \
            --set global.leaderElection.namespace=cert-manager \
            --atomic"
          
          if ! retry_command "$CERT_MANAGER_CMD" "Install cert-manager"; then
            echo "‚ùå Error: Failed to install cert-manager"
            echo "ü¶© Checking cert-manager namespace status..."
            kubectl get pods -n cert-manager
            kubectl describe pods -n cert-manager
            echo "ü¶© Checking cert-manager CRDs..."
            kubectl get crds | grep cert-manager || true
            echo "ü¶© Checking cert-manager logs..."
            kubectl logs -n cert-manager -l app=cert-manager --tail=100 || true
            echo "ü¶© Checking Helm history..."
            helm history cert-manager -n cert-manager || true
            exit 1
          fi
          
          echo "‚úÖ Kubernetes dependencies setup completed"

      - name: Create Kubernetes Secrets üîê ü¶©
        run: |
          echo "ü¶© Creating namespace if not exists..."
          if ! kubectl create namespace ${REGISTRY_NAME} --dry-run=client -o yaml | kubectl apply -f -; then
            echo "‚ùå Error: Failed to create namespace"
            exit 1
          fi
          
          echo "ü¶© Creating registry credentials..."
          if ! kubectl create secret docker-registry registry-credentials \
            --namespace=${REGISTRY_NAME} \
            --docker-server=${REGISTRY} \
            --docker-username=${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }} \
            --docker-password=${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }} \
            --dry-run=client -o yaml | kubectl apply -f -; then
            echo "‚ùå Error: Failed to create registry credentials"
            exit 1
          fi
          
          echo "ü¶© Creating application secrets..."
          # Create a temporary file for the tokens
          echo "${{ secrets.GH_API_TOKENS }}" > github_tokens.txt
          
          # Delete existing secret if it exists
          kubectl delete secret app-secrets --namespace=${REGISTRY_NAME} --ignore-not-found=true
          
          # Create the secret with the correct key
          if ! kubectl create secret generic app-secrets \
            --namespace=${REGISTRY_NAME} \
            --from-literal=github.tokens="${{ secrets.GH_API_TOKENS }}"; then
            echo "‚ùå Error: Failed to create application secrets"
            exit 1
          fi
          
          # Verify secret was created correctly
          echo "ü¶© Verifying secret creation..."
          if ! kubectl get secret app-secrets --namespace=${REGISTRY_NAME} -o jsonpath='{.data}' | grep 'github\.tokens'; then
            echo "‚ùå Error: Secret verification failed"
            exit 1
          fi
          
          echo "‚úÖ Kubernetes secrets created successfully"

      - name: Deploy Kubernetes Configurations üöÄ ü¶©
        env:
          REGISTRY_URL: ${REGISTRY}/${REGISTRY_NAME}
          LETSENCRYPT_EMAIL: ${{ secrets.LETSENCRYPT_EMAIL }}
          DOMAIN_SUFFIX: ${{ secrets.DOMAIN_SUFFIX }}
        run: |
          echo "ü¶© Processing and applying Kubernetes configurations..."
          
          for file in kubernetes/base/*.yaml; do
            echo "ü¶© Processing $file..."
            if ! envsubst < $file | kubectl apply -n ${REGISTRY_NAME} -f -; then
              echo "‚ùå Error: Failed to apply $file"
              exit 1
            fi
          done
          
          echo "ü¶© Waiting for deployments to be ready..."
          
          # Function to check pod status and logs
          check_deployment() {
            local deployment=$1
            echo "ü¶© Checking status for deployment: $deployment"
            
            # Get pod status
            echo "ü¶© Pod status:"
            kubectl -n ${REGISTRY_NAME} get pods -l app=$deployment -o wide
            
            # Get failed pods if any
            failed_pods=$(kubectl -n ${REGISTRY_NAME} get pods -l app=$deployment -o jsonpath='{.items[?(@.status.phase!="Running")].metadata.name}')
            
            if [ ! -z "$failed_pods" ]; then
              echo "ü¶© Found failed pods: $failed_pods"
              for pod in $failed_pods; do
                echo "ü¶© Logs for failed pod $pod:"
                kubectl -n ${REGISTRY_NAME} logs $pod --all-containers --tail=50
                
                echo "ü¶© Events for failed pod $pod:"
                kubectl -n ${REGISTRY_NAME} get events --field-selector involvedObject.name=$pod
                
                echo "ü¶© Describing failed pod $pod:"
                kubectl -n ${REGISTRY_NAME} describe pod $pod
              done
            fi
          }
          
          # Wait for backend deployment
          echo "ü¶© Waiting for backend deployment..."
          if ! kubectl -n ${REGISTRY_NAME} rollout status deployment/backend --timeout=5m; then
            echo "‚ùå Error: Backend deployment failed to roll out"
            check_deployment "backend"
            exit 1
          fi
          
          # Wait for frontend deployment
          echo "ü¶© Waiting for frontend deployment..."
          if ! kubectl -n ${REGISTRY_NAME} rollout status deployment/frontend --timeout=5m; then
            echo "‚ùå Error: Frontend deployment failed to roll out"
            check_deployment "frontend"
            exit 1
          fi
          
          echo "‚úÖ Kubernetes configurations deployed successfully"

      - name: Update DNS Records üåç ü¶©
        run: |
          echo "ü¶© Getting LoadBalancer IP..."
          LB_IP=""
          RETRY_COUNT=0
          MAX_RETRIES=30
          
          while [ -z "$LB_IP" ] && [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            LB_IP=$(kubectl -n ingress-nginx get service ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
            if [ -z "$LB_IP" ]; then
              echo "ü¶© Waiting for LoadBalancer IP... (Attempt $((RETRY_COUNT + 1))/$MAX_RETRIES)"
              sleep 10
              RETRY_COUNT=$((RETRY_COUNT + 1))
            fi
          done
          
          if [ -z "$LB_IP" ]; then
            echo "‚ùå Error: Failed to get LoadBalancer IP after $MAX_RETRIES attempts"
            exit 1
          fi
          
          echo "ü¶© Finding existing DNS records..."
          EXISTING_RECORDS=$(doctl compute domain records list ${{ secrets.DOMAIN_SUFFIX }} --format ID,Type,Name --no-header | grep "^[0-9]* *A *${{ env.DOMAIN_NAME }}" || true)
          
          if [ ! -z "$EXISTING_RECORDS" ]; then
            echo "ü¶© Found existing records to delete:"
            echo "$EXISTING_RECORDS"
            
            echo "ü¶© Deleting existing records..."
            while IFS= read -r record; do
              RECORD_ID=$(echo $record | awk '{print $1}')
              echo "ü¶© Deleting record ID: $RECORD_ID"
              if ! doctl compute domain records delete ${{ secrets.DOMAIN_SUFFIX }} $RECORD_ID --force; then
                echo "‚ö†Ô∏è Warning: Failed to delete record $RECORD_ID"
              fi
            done <<< "$EXISTING_RECORDS"
          else
            echo "ü¶© No existing records found"
          fi
          
          echo "ü¶© Creating new DNS A record..."
          if ! doctl compute domain records create ${{ secrets.DOMAIN_SUFFIX }} \
            --record-type A \
            --record-name "${{ env.DOMAIN_NAME }}" \
            --record-data "${LB_IP}" \
            --record-ttl 300; then
            echo "‚ùå Error: Failed to create DNS record"
            exit 1
          fi
          
          echo "‚úÖ DNS records updated successfully"

      - name: Verify Deployment üîç ü¶©
        run: |
          echo "ü¶© Checking deployment status..."
          
          echo "ü¶© Pod Status:"
          kubectl -n ${REGISTRY_NAME} get pods -o wide
          
          echo "ü¶© Service Status:"
          kubectl -n ${REGISTRY_NAME} get services
          
          echo "ü¶© Ingress Status:"
          kubectl -n ${REGISTRY_NAME} get ingress
          
          echo "ü¶© Certificate Status:"
          kubectl -n ${REGISTRY_NAME} get certificates
          
          echo "ü¶© Events:"
          kubectl -n ${REGISTRY_NAME} get events --sort-by='.lastTimestamp'
          
          # Verify all pods are running
          failed_pods=$(kubectl -n ${REGISTRY_NAME} get pods -o jsonpath='{.items[?(@.status.phase!="Running")].metadata.name}')
          if [ ! -z "$failed_pods" ]; then
            echo "‚ùå Error: The following pods are not running:"
            echo "$failed_pods"
            
            for pod in $failed_pods; do
              echo "ü¶© Describing failed pod $pod:"
              kubectl -n ${REGISTRY_NAME} describe pod $pod
              
              echo "ü¶© Logs for failed pod $pod:"
              kubectl -n ${REGISTRY_NAME} logs $pod --all-containers --tail=50 || true
            done
            exit 1
          fi
          
          echo "‚úÖ Deployment verification completed"

      - name: Cleanup Old Images üßπ ü¶©
        run: |
          echo "ü¶© Getting repository list..."
          REPOS="backend frontend"
          
          for REPO in $REPOS; do
            echo "ü¶© Processing repository: $REPO"
            
            # Get all manifests and their associated tags
            echo "ü¶© Getting manifests for $REPO..."
            MANIFESTS=$(doctl registry repository list-manifests $REPO --format Digest,Tags,CompressedSize --no-header)
            
            echo "ü¶© Found manifests:"
            echo "$MANIFESTS"
            
            # Process each manifest
            while IFS=$'\t' read -r DIGEST TAGS SIZE; do
              # Skip if manifest has the latest tag or current version
              if [[ "$TAGS" == *"latest"* ]] || [[ "$TAGS" == *"$VERSION"* ]]; then
                echo "ü¶© Keeping manifest $DIGEST (has latest or current version: $VERSION)"
                continue
              fi
              
              echo "ü¶© Processing manifest: $DIGEST (Size: $SIZE)"
              
              # First delete all tags associated with this manifest
              if [ ! -z "$TAGS" ] && [ "$TAGS" != "[]" ]; then
                # Convert comma-separated list to array
                IFS=',' read -ra TAG_ARRAY <<< "$TAGS"
                for TAG in "${TAG_ARRAY[@]}"; do
                  # Clean up the tag (remove brackets and spaces)
                  TAG=$(echo "$TAG" | tr -d '[][:space:]')
                  if [ ! -z "$TAG" ] && [ "$TAG" != "latest" ] && [ "$TAG" != "$VERSION" ]; then
                    echo "ü¶© Deleting tag: $REPO:$TAG"
                    if ! doctl registry repository delete-tag $REPO $TAG --force; then
                      echo "‚ö†Ô∏è Warning: Failed to delete tag $TAG"
                    fi
                  else
                    echo "ü¶© Skipping protected tag: $TAG"
                  fi
                done
              fi
              
              # Check if all tags were deleted before deleting the manifest
              REMAINING_TAGS=$(doctl registry repository list-tags $REPO --format Tag --no-header | grep "^$DIGEST" || true)
              if [ -z "$REMAINING_TAGS" ]; then
                echo "ü¶© Deleting manifest: $DIGEST"
                if ! doctl registry repository delete-manifest $REPO "$DIGEST" --force; then
                  echo "‚ö†Ô∏è Warning: Failed to delete manifest $DIGEST"
                fi
              else
                echo "ü¶© Skipping manifest deletion as it still has tags: $REMAINING_TAGS"
              fi
            done <<< "$MANIFESTS"
          done
          
          echo "ü¶© Checking for active garbage collection..."
          GC_STATUS=$(doctl registry garbage-collection get-active --format Status --no-header || echo "none")
          
          if [ "$GC_STATUS" == "none" ]; then
            echo "ü¶© Starting garbage collection..."
            if ! doctl registry garbage-collection start --force; then
              echo "‚ö†Ô∏è Warning: Failed to start garbage collection"
            fi
          else
            echo "‚ö†Ô∏è Garbage collection already running, skipping..."
          fi
          
          echo "‚úÖ Image cleanup completed"

      - name: Create GitHub Deployment üì¶ ü¶©
        uses: chrnorm/deployment-action@v2
        with:
          token: ${{ secrets.GH_PAT }}
          environment: production
          initial-status: success
          environment-url: https://${{ env.DOMAIN_NAME }}.${{ secrets.DOMAIN_SUFFIX }}

      - name: Set environment variables
        run: |
          echo "DOMAIN_NAME=major-league-github" >> $GITHUB_ENV
          echo "ENVIRONMENT=production" >> $GITHUB_ENV
          echo "BACKEND_REPLICAS=2" >> $GITHUB_ENV
          echo "FRONTEND_REPLICAS=2" >> $GITHUB_ENV
          # Reduced resource requests and limits
          echo "BACKEND_REQUEST_MEMORY=512Mi" >> $GITHUB_ENV
          echo "BACKEND_REQUEST_CPU=200m" >> $GITHUB_ENV
          echo "BACKEND_LIMIT_MEMORY=1Gi" >> $GITHUB_ENV
          echo "BACKEND_LIMIT_CPU=500m" >> $GITHUB_ENV
          echo "FRONTEND_REQUEST_MEMORY=128Mi" >> $GITHUB_ENV
          echo "FRONTEND_REQUEST_CPU=100m" >> $GITHUB_ENV
          echo "FRONTEND_LIMIT_MEMORY=256Mi" >> $GITHUB_ENV
          echo "FRONTEND_LIMIT_CPU=200m" >> $GITHUB_ENV
          echo "JAVA_MAX_HEAP=768m" >> $GITHUB_ENV
          echo "JAVA_MIN_HEAP=512m" >> $GITHUB_ENV


