name: Build and Deploy Major League Github on GCP üöÄ ‚òÅÔ∏è

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  PROJECT_NAME: ${{ secrets.PROJECT_NAME }}
  VERSION: v1.0.${{ github.run_number }}
  ENVIRONMENT: production
  
  # Google Tag Manager
  GTM_ID: ${{ secrets.GTM_ID }}
  
  # GCP Configuration
  GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  GKE_CLUSTER: ${{ secrets.GKE_CLUSTER }}
  GKE_ZONE: ${{ secrets.GKE_ZONE }}
  
  # GitHub Container Registry
  REGISTRY: ghcr.io
  REGISTRY_NAME: ${{ github.repository }}
  
  # Kubernetes namespace (convert repo name to valid namespace)
  NAMESPACE: ${{ github.event.repository.name }}

  DOMAIN_NAME: ${{ secrets.DOMAIN_NAME }}
  DOMAIN_SUFFIX: ${{ secrets.DOMAIN_SUFFIX }}
  STATIC_IP_NAME: "main-ingress-ip"
  STATIC_IP_ADDRESS: ${{ secrets.STATIC_IP_ADDRESS }}

  GH_API_TOKENS: ${{ secrets.GH_API_TOKENS }}
  
  # LinkedIn
  LINKEDIN_CLIENT_ID: ${{ secrets.LINKEDIN_CLIENT_ID }}
  LINKEDIN_CLIENT_SECRET: ${{ secrets.LINKEDIN_CLIENT_SECRET }}
  
  # Resource configuration
  BACKEND_REPLICAS: 1
  FRONTEND_REPLICAS: 1
  
  # Backend resources (minimal for single-node cluster)
  BACKEND_REQUEST_MEMORY: 256Mi
  BACKEND_REQUEST_CPU: 50m
  BACKEND_LIMIT_MEMORY: 1Gi
  BACKEND_LIMIT_CPU: 500m
  
  # Frontend resources (minimal for single-node cluster)
  FRONTEND_REQUEST_MEMORY: 64Mi
  FRONTEND_REQUEST_CPU: 25m
  FRONTEND_LIMIT_MEMORY: 256Mi
  FRONTEND_LIMIT_CPU: 200m
  
  # Java settings
  JAVA_MAX_HEAP: 1200m
  JAVA_MIN_HEAP: 512m
  
  # Redis Configuration
  REDIS_HOST: ${{ secrets.REDIS_IP }}

jobs:
  build-and-deploy:
    runs-on: ubuntu-22.04
    permissions:
      contents: read
      packages: write
      deployments: write

    steps:
      - name: Verify Required Secrets üîí
        run: |
          missing_secrets=()
          
          # Core project secrets
          if [ -z "${{ secrets.PROJECT_NAME }}" ]; then
            missing_secrets+=("PROJECT_NAME")
          fi
          
          # GCP Infrastructure secrets
          if [ -z "${{ secrets.GCP_PROJECT_ID }}" ]; then
            missing_secrets+=("GCP_PROJECT_ID")
          fi
          
          if [ -z "${{ secrets.GCP_SA_KEY }}" ]; then
            missing_secrets+=("GCP_SA_KEY")
          fi
          
          if [ -z "${{ secrets.GKE_CLUSTER }}" ]; then
            missing_secrets+=("GKE_CLUSTER")
          fi
          
          if [ -z "${{ secrets.GKE_ZONE }}" ]; then
            missing_secrets+=("GKE_ZONE")
          fi
          
          # Container Registry auto-detected from repository
          
          # DNS secrets
          if [ -z "${{ secrets.DNS_PROJECT_ID }}" ]; then
            missing_secrets+=("DNS_PROJECT_ID")
          fi
          
          if [ -z "${{ secrets.DNS_ZONE }}" ]; then
            missing_secrets+=("DNS_ZONE")
          fi
          
          # Redis secret
          if [ -z "${{ secrets.REDIS_IP }}" ]; then
            missing_secrets+=("REDIS_IP")
          fi
          
          # Domain secrets
          if [ -z "${{ secrets.DOMAIN_NAME }}" ]; then
            missing_secrets+=("DOMAIN_NAME")
          fi
          
          if [ -z "${{ secrets.DOMAIN_SUFFIX }}" ]; then
            missing_secrets+=("DOMAIN_SUFFIX")
          fi
          
          # Application secrets
          if [ -z "${{ secrets.GH_API_TOKENS }}" ]; then
            missing_secrets+=("GH_API_TOKENS")
          fi
          
          if [ -z "${{ secrets.LINKEDIN_CLIENT_ID }}" ]; then
            missing_secrets+=("LINKEDIN_CLIENT_ID")
          fi
          
          if [ -z "${{ secrets.LINKEDIN_CLIENT_SECRET }}" ]; then
            missing_secrets+=("LINKEDIN_CLIENT_SECRET")
          fi
          
          if [ -z "${{ secrets.GTM_ID }}" ]; then
            missing_secrets+=("GTM_ID")
          fi
          
          if [ ${#missing_secrets[@]} -ne 0 ]; then
            echo "‚ùå Error: Missing required secrets: ${missing_secrets[*]}"
            exit 1
          fi
          
          echo "‚úÖ All required secrets are set"

      - name: Checkout code üì¶
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Google Cloud CLI üõ†Ô∏è
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Configure gcloud üîß
        uses: google-github-actions/setup-gcloud@v2

      - name: Get GKE credentials üîë
        uses: google-github-actions/get-gke-credentials@v2
        with:
          cluster_name: ${{ env.GKE_CLUSTER }}
          location: ${{ env.GKE_ZONE }}

      - name: Login to GitHub Container Registry üê≥
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set Webapp Environment Variables üé®
        run: |
          # Set OG Meta Tags environment variables
          echo "OG_TITLE=Major League GitHub" >> $GITHUB_ENV
          echo "OG_DESCRIPTION=GitHub Scouting Report: Major League Edition" >> $GITHUB_ENV
          echo "OG_TYPE=website" >> $GITHUB_ENV
          echo "OG_IMAGE_URL=/og-image.png" >> $GITHUB_ENV
          echo "OG_SITE_NAME=Major League GitHub" >> $GITHUB_ENV
          
          # Set Extra Button environment variables
          echo "WEBAPP_EXTRA_BUTTON_LINK=https://medium.com/@michaelassraf/major-league-github-the-open-source-talent-leaderboard-ca2c6d7dcbeb" >> $GITHUB_ENV
          echo "WEBAPP_EXTRA_BUTTON_TEXT=Why MLG?" >> $GITHUB_ENV

      - name: Build and push backend service image üèóÔ∏è
        run: |
          echo "üöÄ Building backend service image..."
          docker build \
            --build-arg PROFILE=backend-service \
            -t ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/backend-service:${{ env.VERSION }} \
            -t ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/backend-service:latest \
            backend
          
          echo "üöÄ Pushing backend service images..."
          docker push ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/backend-service:${{ env.VERSION }}
          docker push ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/backend-service:latest

      - name: Build and push cache updater image üèóÔ∏è
        run: |
          echo "üöÄ Building cache updater image..."
          docker build \
            --build-arg PROFILE=cache-updater \
            -t ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/cache-updater:${{ env.VERSION }} \
            -t ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/cache-updater:latest \
            backend
          
          echo "üöÄ Pushing cache updater images..."
          docker push ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/cache-updater:${{ env.VERSION }}
          docker push ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/cache-updater:latest

      - name: Build and push frontend image üé®
        env:
          OG_TITLE: ${{ env.OG_TITLE }}
          OG_DESCRIPTION: ${{ env.OG_DESCRIPTION }}
          OG_TYPE: ${{ env.OG_TYPE }}
          OG_IMAGE_URL: ${{ env.OG_IMAGE_URL }}
          OG_SITE_NAME: ${{ env.OG_SITE_NAME }}
          WEBAPP_EXTRA_BUTTON_LINK: ${{ env.WEBAPP_EXTRA_BUTTON_LINK }}
          WEBAPP_EXTRA_BUTTON_TEXT: ${{ env.WEBAPP_EXTRA_BUTTON_TEXT }}
        run: |
          echo "üöÄ Building frontend image..."
          docker build frontend \
            --build-arg NODE_ENV=production \
            --build-arg BACKEND_API_URL="https://${{ env.DOMAIN_NAME }}.${{ env.DOMAIN_SUFFIX }}" \
            --build-arg GTM_ID="${{ env.GTM_ID }}" \
            --build-arg OG_TITLE="${{ env.OG_TITLE }}" \
            --build-arg OG_DESCRIPTION="${{ env.OG_DESCRIPTION }}" \
            --build-arg OG_TYPE="${{ env.OG_TYPE }}" \
            --build-arg OG_IMAGE_URL="${{ env.OG_IMAGE_URL }}" \
            --build-arg OG_URL="https://${{ env.DOMAIN_NAME }}.${{ env.DOMAIN_SUFFIX }}" \
            --build-arg OG_SITE_NAME="${{ env.OG_SITE_NAME }}" \
            --build-arg WEBAPP_EXTRA_BUTTON_LINK="${{ env.WEBAPP_EXTRA_BUTTON_TEXT }}" \
            --build-arg WEBAPP_EXTRA_BUTTON_TEXT="${{ env.WEBAPP_EXTRA_BUTTON_TEXT }}" \
            -t "${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/frontend:${{ env.VERSION }}" \
            -t "${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/frontend:latest"
          
          echo "üöÄ Pushing frontend images..."
          docker push ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/frontend:${{ env.VERSION }}
          docker push ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/frontend:latest

      - name: Create Kubernetes namespace and secrets üîê
        run: |
          # Create namespace
          kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
          
          # Create application secrets
          kubectl create secret generic app-secrets \
            --namespace=${{ env.NAMESPACE }} \
            --from-literal=github.tokens="${{ env.GH_API_TOKENS }}" \
            --from-literal=linkedin.client.id="${{ env.LINKEDIN_CLIENT_ID }}" \
            --from-literal=linkedin.client.secret="${{ env.LINKEDIN_CLIENT_SECRET }}" \
            --dry-run=client -o yaml | kubectl apply -f -
          
          echo "‚úÖ Kubernetes secrets created successfully"

      - name: Deploy to GKE üöÄ
        env:
          REGISTRY_URL: ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}
          DOMAIN_SUFFIX: ${{ env.DOMAIN_SUFFIX }}
          DOMAIN_NAME: ${{ env.DOMAIN_NAME }}
          ENVIRONMENT: ${{ env.ENVIRONMENT }}
          VERSION: ${{ env.VERSION }}
          BACKEND_SERVICE_NAME: "backend-service"
          CACHE_UPDATER_NAME: "cache-updater" 
          BACKEND_SERVICE_PORT: "8080"
          CACHE_UPDATER_PORT: "8081"
          FRONTEND_PORT: "80"
          STATIC_IP_ADDRESS: ${{ secrets.STATIC_IP_ADDRESS }}
        run: |
          echo "üöÄ Processing and applying Kubernetes configurations..."
          
          # Create temporary directory
          mkdir -p processed_k8s
          
          # Process config files
          echo "üöÄ Processing config.yaml..."
          envsubst < kubernetes/base/config.yaml > processed_k8s/config.yaml
          kubectl apply -n ${{ env.NAMESPACE }} -f processed_k8s/config.yaml
          
          # Process and apply backend service
          echo "üöÄ Processing backend service..."
          SERVICE_NAME=backend-service \
          SERVER_PORT=8080 \
            envsubst < kubernetes/base/backend-service.yaml > processed_k8s/backend-service.yaml
          kubectl apply -n ${{ env.NAMESPACE }} -f processed_k8s/backend-service.yaml
          
          # Process and apply cache updater
          echo "üöÄ Processing cache updater..."
          SERVICE_NAME=cache-updater \
          SERVER_PORT=8081 \
            envsubst < kubernetes/base/cache-updater-service.yaml > processed_k8s/cache-updater.yaml
          kubectl apply -n ${{ env.NAMESPACE }} -f processed_k8s/cache-updater.yaml
          
          # Clean up old resources
          echo "üßπ Cleaning up old resources..."
          kubectl delete ingress main-ingress -n ${{ env.NAMESPACE }} --ignore-not-found=true || echo "No old ingress found"
          kubectl delete service unified-proxy-service -n ${{ env.NAMESPACE }} --ignore-not-found=true || echo "No old unified-proxy-service found"  
          kubectl delete service main-loadbalancer -n ${{ env.NAMESPACE }} --ignore-not-found=true || echo "No old main-loadbalancer found"
          kubectl delete service frontend-loadbalancer -n ${{ env.NAMESPACE }} --ignore-not-found=true || echo "No old frontend-loadbalancer found"
          kubectl delete service backend-loadbalancer -n ${{ env.NAMESPACE }} --ignore-not-found=true || echo "No old backend-loadbalancer found"
          kubectl delete deployment unified-proxy -n ${{ env.NAMESPACE }} --ignore-not-found=true || echo "No old unified-proxy found"
          kubectl delete configmap unified-proxy-config -n ${{ env.NAMESPACE }} --ignore-not-found=true || echo "No old unified-proxy-config found"
          
          # Wait for cleanup to complete
          echo "‚è≥ Waiting for cleanup to complete..."
          sleep 5
          
          # Process and apply frontend (creates frontend-service as ClusterIP with NEG)
          echo "üöÄ Processing frontend..."
          envsubst < kubernetes/base/frontend.yaml > processed_k8s/frontend.yaml
          kubectl apply -n ${{ env.NAMESPACE }} -f processed_k8s/frontend.yaml
          echo "‚úÖ Frontend applied successfully"
          
          # Clean up any pending pods
          echo "üßπ Cleaning up any stuck/pending pods..."
          kubectl delete pods -n ${{ env.NAMESPACE }} --field-selector status.phase=Pending --force --grace-period=0 || echo "No pending pods to clean up"
          echo "‚úÖ Cleanup completed"
          
          # Remove old resources if they exist
          echo "üßπ Cleaning up old resources..."
          kubectl delete deployment nginx-proxy -n ${{ env.NAMESPACE }} --ignore-not-found=true
          kubectl delete service nginx-proxy-service -n ${{ env.NAMESPACE }} --ignore-not-found=true
          kubectl delete service frontend-load-balancer -n ${{ env.NAMESPACE }} --ignore-not-found=true
          kubectl delete service backend-load-balancer -n ${{ env.NAMESPACE }} --ignore-not-found=true
          kubectl delete service main-load-balancer -n ${{ env.NAMESPACE }} --ignore-not-found=true
          kubectl delete configmap nginx-proxy-config -n ${{ env.NAMESPACE }} --ignore-not-found=true
          
          # Wait a moment for cleanup
          sleep 5
          
          # Check deployment status immediately after creation
          echo "üîç Immediate deployment status check..."
          kubectl get deployments -n ${{ env.NAMESPACE }} -o wide
          kubectl get pods -n ${{ env.NAMESPACE }} -o wide
          kubectl get events -n ${{ env.NAMESPACE }} --sort-by='.lastTimestamp' | tail -20
          
          echo "üîç Cache-updater specific details:"
          kubectl describe deployment/cache-updater -n ${{ env.NAMESPACE }}
          echo "üîç Cache-updater pod details:"
          kubectl describe pods -n ${{ env.NAMESPACE }} -l app=cache-updater
          echo "üîç Cache-updater logs (if any):"
          kubectl logs -n ${{ env.NAMESPACE }} -l app=cache-updater --tail=50 || echo "No logs yet"
          
          # Wait for deployments to be ready
          echo "üöÄ Now waiting for deployments to be ready..."
          kubectl wait --for=condition=available deployment/backend-service -n ${{ env.NAMESPACE }} --timeout=300s
          kubectl wait --for=condition=available deployment/cache-updater -n ${{ env.NAMESPACE }} --timeout=300s
          kubectl wait --for=condition=available deployment/frontend -n ${{ env.NAMESPACE }} --timeout=300s
          
          # Create static IP if it doesn't exist
          echo "üöÄ Ensuring static IP exists..."
          if ! gcloud compute addresses describe main-ingress-ip --global >/dev/null 2>&1; then
            echo "Creating static IP main-ingress-ip with address ${STATIC_IP_ADDRESS}..."
            gcloud compute addresses create main-ingress-ip --global --addresses=${STATIC_IP_ADDRESS}
          else
            echo "Static IP main-ingress-ip already exists"
          fi
          
          # Create ingress AFTER all services exist with static IP
          echo "üöÄ Processing ingress after services are ready..."
          envsubst < kubernetes/base/ingress.yaml > processed_k8s/ingress.yaml
          kubectl apply -n ${{ env.NAMESPACE }} -f processed_k8s/ingress.yaml
          
          # Cleanup
          rm -rf processed_k8s
          
          echo "‚úÖ Deployment completed successfully"

      - name: Verify Deployment üîç
        run: |
          echo "üîç Checking deployment status..."
          
          echo "Pod Status:"
          kubectl -n ${{ env.NAMESPACE }} get pods -o wide
          
          echo "Service Status:"
          kubectl -n ${{ env.NAMESPACE }} get services
          
          echo "LoadBalancer Status:"
          kubectl -n ${{ env.NAMESPACE }} get ingress main-ingress -o wide
          
          # Use static IP instead of waiting for dynamic assignment
          LB_IP="${{ env.STATIC_IP_ADDRESS }}"
          echo "‚úÖ Using static IP: ${LB_IP}"
          echo "üåê Frontend URL: http://${LB_IP}/"
          echo "üåê Backend API URL: http://${LB_IP}/api/actuator/health"
          
          echo "‚úÖ Migration Complete - Proper Kubernetes Architecture!"
          echo "üåê Single External Gateway: http://${LB_IP}"
          echo "   - Frontend: http://${LB_IP}/"
          echo "   - API: http://${LB_IP}/api"
          echo ""
          echo "üîí Internal Services (ClusterIP only):"
          echo "   - frontend-service:80 (internal)"
          echo "   - backend-service-service:8080 (internal)"
          echo ""
          echo "üåç Domain: https://${{ env.DOMAIN_NAME }}.${{ env.DOMAIN_SUFFIX }}"

      - name: Update DNS Record (Cross-Project) üåç
        run: |
          LB_IP="${{ env.STATIC_IP_ADDRESS }}"
          echo "üåç Updating DNS record for ${{ env.DOMAIN_NAME }}.${{ env.DOMAIN_SUFFIX }} to ${LB_IP}"
          
          # DNS project details
          DNS_PROJECT_ID="${{ secrets.DNS_PROJECT_ID }}"
          DNS_ZONE="${{ secrets.DNS_ZONE }}"
          
          # Set project context to DNS project
          gcloud config set project $DNS_PROJECT_ID
          
          # Debug: List all DNS zones in the project
          echo "üîç Available DNS zones in project $DNS_PROJECT_ID:"
          gcloud dns managed-zones list --project=$DNS_PROJECT_ID --format="table(name,dnsName)" || echo "No zones found or permission denied"
          
          echo "üîç Looking for DNS zone: $DNS_ZONE"
          
          # Check if DNS zone exists
          if ! gcloud dns managed-zones describe $DNS_ZONE --project=$DNS_PROJECT_ID --format="value(name)" > /dev/null 2>&1; then
            echo "‚ùå Cloud DNS zone '$DNS_ZONE' not found in project $DNS_PROJECT_ID"
            echo "üåç FALLBACK - Manual DNS Update Required:"
            echo "Load Balancer IP: ${LB_IP}"
            echo "Go to: https://console.cloud.google.com/net-services/dns/zones?project=$DNS_PROJECT_ID"
            exit 1
          fi
          
          # Get existing A record if it exists
          EXISTING_IP=$(gcloud dns record-sets list --zone=$DNS_ZONE --project=$DNS_PROJECT_ID --name="${{ env.DOMAIN_NAME }}.${{ env.DOMAIN_SUFFIX }}." --type=A --format="value(rrdatas[0])" 2>/dev/null | head -1 || echo "")
          
          if [ ! -z "$EXISTING_IP" ] && [ "$EXISTING_IP" != "null" ] && [ "$EXISTING_IP" != "$LB_IP" ]; then
            echo "üåç Updating existing A record from $EXISTING_IP to $LB_IP"
            
            # Get the existing record with full details including TTL
            EXISTING_TTL=$(gcloud dns record-sets list --zone=$DNS_ZONE --project=$DNS_PROJECT_ID --name="${{ env.DOMAIN_NAME }}.${{ env.DOMAIN_SUFFIX }}." --type=A --format="value(ttl)" 2>/dev/null | head -1)
            
            if [ ! -z "$EXISTING_TTL" ] && [ "$EXISTING_TTL" != "null" ]; then
              echo "Found existing record: TTL=$EXISTING_TTL, IP=$EXISTING_IP"
              
              # Use transaction to update the record with exact existing values
              gcloud dns record-sets transaction start --zone=$DNS_ZONE --project=$DNS_PROJECT_ID
              gcloud dns record-sets transaction remove "$EXISTING_IP" \
                --name="${{ env.DOMAIN_NAME }}.${{ env.DOMAIN_SUFFIX }}." \
                --ttl=$EXISTING_TTL \
                --type=A \
                --zone=$DNS_ZONE --project=$DNS_PROJECT_ID
              gcloud dns record-sets transaction add "$LB_IP" \
                --name="${{ env.DOMAIN_NAME }}.${{ env.DOMAIN_SUFFIX }}." \
                --ttl=300 \
                --type=A \
                --zone=$DNS_ZONE --project=$DNS_PROJECT_ID
              gcloud dns record-sets transaction execute --zone=$DNS_ZONE --project=$DNS_PROJECT_ID
            else
              echo "Could not find existing record details, will create new record instead"
              # Fall back to creating new record
              gcloud dns record-sets transaction start --zone=$DNS_ZONE --project=$DNS_PROJECT_ID
              gcloud dns record-sets transaction add "$LB_IP" \
                --name="${{ env.DOMAIN_NAME }}.${{ env.DOMAIN_SUFFIX }}." \
                --ttl=300 \
                --type=A \
                --zone=$DNS_ZONE --project=$DNS_PROJECT_ID
              gcloud dns record-sets transaction execute --zone=$DNS_ZONE --project=$DNS_PROJECT_ID
            fi
            
          elif [ -z "$EXISTING_IP" ] || [ "$EXISTING_IP" = "null" ]; then
            echo "üåç Creating new A record pointing to $LB_IP"
            
            # Create new A record
            gcloud dns record-sets transaction start --zone=$DNS_ZONE --project=$DNS_PROJECT_ID
            gcloud dns record-sets transaction add "$LB_IP" \
              --name="${{ env.DOMAIN_NAME }}.${{ env.DOMAIN_SUFFIX }}." \
              --ttl=300 \
              --type=A \
              --zone=$DNS_ZONE --project=$DNS_PROJECT_ID
            gcloud dns record-sets transaction execute --zone=$DNS_ZONE --project=$DNS_PROJECT_ID
            
          else
            echo "üåç DNS record already points to correct IP: $LB_IP"
          fi
          
          echo "‚úÖ DNS record updated successfully"
          echo "üåç Domain will be accessible at: https://${{ env.DOMAIN_NAME }}.${{ env.DOMAIN_SUFFIX }}"
          echo "‚è≥ DNS propagation may take 5-15 minutes"
          
          # Switch back to original project
          gcloud config set project ${{ env.GCP_PROJECT_ID }}

      - name: Create GitHub Deployment üì¶
        uses: chrnorm/deployment-action@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          environment: production
          initial-status: success
          environment-url: https://${{ env.DOMAIN_NAME }}.${{ env.DOMAIN_SUFFIX }}