name: Build and Deploy ğŸš€ ğŸ¦©

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  URL_SUFFIX: "flamingo.cx"
  URL_PREFIX: "major-league-github"
  APP_URL: "https://major-league-github.flamingo.cx"
  

jobs:
  build-and-deploy:
    runs-on: ubuntu-22.04
    permissions:
      contents: read
      packages: write
      deployments: write

    steps:
      - name: Checkout code ğŸ“¦
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}

      - name: Set registry name ğŸ·ï¸
        run: |
          echo "REGISTRY_NAME=$(echo ${{ github.repository_owner }} | tr '[:upper:]' '[:lower:]')" >> $GITHUB_ENV

      - name: Log in to GitHub Container Registry ğŸ”‘
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Install doctl ğŸ› ï¸
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

      - name: Create or get Kubernetes cluster ğŸ¯ ğŸ¦©
        run: |
          echo "ğŸ¦© Checking if cluster exists..."
          if ! doctl kubernetes cluster get ${{ secrets.DIGITALOCEAN_CLUSTER_NAME }} &>/dev/null; then
            echo "ğŸ¦© Cluster not found, creating new cluster..."
            doctl kubernetes cluster create ${{ secrets.DIGITALOCEAN_CLUSTER_NAME }} \
              --region sfo3 \
              --size s-2vcpu-4gb \
              --count 2 \
              --version latest \
              --wait
            echo "ğŸ¦© Cluster created successfully!"
          else
            echo "ğŸ¦© Cluster already exists!"
          fi

      - name: Save DigitalOcean kubeconfig ğŸ’¾
        run: |
          doctl kubernetes cluster kubeconfig save ${{ secrets.DIGITALOCEAN_CLUSTER_NAME }}

      - name: Build and push backend image ğŸ—ï¸ ğŸ¦©
        env:
          VERSION: v1.0.${{ github.run_number }}
        run: |
          echo "ğŸ¦© Building backend image..."
          docker build -t ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/${{ secrets.IMAGE_NAME }}-backend:${VERSION} -t ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/${{ secrets.IMAGE_NAME }}-backend:latest ./backend
          echo "ğŸ¦© Pushing backend image..."
          docker push ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/${{ secrets.IMAGE_NAME }}-backend:${VERSION}
          docker push ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/${{ secrets.IMAGE_NAME }}-backend:latest

      - name: Build and push frontend image ğŸ¨ ğŸ¦©
        env:
          VERSION: v1.0.${{ github.run_number }}
        run: |
          echo "ğŸ¦© Building frontend image..."
          docker build -t ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/${{ secrets.IMAGE_NAME }}-frontend:${VERSION} -t ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/${{ secrets.IMAGE_NAME }}-frontend:latest ./frontend
          echo "ğŸ¦© Pushing frontend image..."
          docker push ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/${{ secrets.IMAGE_NAME }}-frontend:${VERSION}
          docker push ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/${{ secrets.IMAGE_NAME }}-frontend:latest

      - name: Configure Kubernetes registry access ğŸ”‘
        run: |
          echo "ğŸ¦© Creating registry secret in Kubernetes..."
          kubectl delete secret github-registry --ignore-not-found
          kubectl create secret docker-registry github-registry \
            --docker-server=${{ env.REGISTRY }} \
            --docker-username=${{ github.actor }} \
            --docker-password=${{ secrets.GITHUB_TOKEN }} \
            --docker-email=${{ secrets.LETSENCRYPT_EMAIL }}
          
          echo "ğŸ¦© Patching default service account..."
          kubectl patch serviceaccount default -p '{"imagePullSecrets": [{"name": "github-registry"}]}'

      - name: Install Helm âš“
        run: |
          echo "ğŸ¦© Installing Helm..."
          cURL https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3 | bash

      - name: Install NGINX Ingress Controller ğŸŒ ğŸ¦©
        run: |
          echo "ğŸ¦© Setting up NGINX Ingress..."
          helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
          helm repo update
          helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx \
            --namespace ingress-nginx --create-namespace \
            --set controller.publishService.enabled=true
          
          echo "ğŸ¦© Waiting for NGINX Ingress pods to be ready..."
          kubectl wait --namespace ingress-nginx \
            --for=condition=ready pod \
            --selector=app.kubernetes.io/component=controller \
            --timeout=120s

      - name: Install cert-manager ğŸ”’ ğŸ¦©
        run: |
          echo "ğŸ¦© Setting up cert-manager..."
          helm repo add jetstack https://charts.jetstack.io
          helm repo update
          
          # Check if there's any Helm operation in progress
          echo "ğŸ¦© Checking for ongoing Helm operations..."
          while helm list --pending -A | grep -q "pending"; do
            echo "ğŸ¦© Waiting for other Helm operations to complete..."
            sleep 10
          done
          
          helm upgrade --install cert-manager jetstack/cert-manager \
            --namespace cert-manager --create-namespace \
            --set installCRDs=true

      - name: Wait for cert-manager to be ready â³
        run: |
          echo "ğŸ¦© Waiting for cert-manager..."
          kubectl wait --for=condition=ready pod -l app.kubernetes.io/instance=cert-manager -n cert-manager --timeout=300s

      - name: Create ClusterIssuer ğŸ”‘ ğŸ¦©
        run: |
          echo "ğŸ¦© Creating Let's Encrypt ClusterIssuer..."
          cat <<EOF | kubectl apply -f -
          apiVersion: cert-manager.io/v1
          kind: ClusterIssuer
          metadata:
            name: letsencrypt-prod
          spec:
            acme:
              server: https://acme-v02.api.letsencrypt.org/directory
              email: ${LETSENCRYPT_EMAIL}
              privateKeySecretRef:
                name: letsencrypt-prod
              solvers:
              - http01:
                  ingress:
                    class: nginx
          EOF
        env:
          LETSENCRYPT_EMAIL: ${{ secrets.LETSENCRYPT_EMAIL }}

      - name: Wait for NGINX Ingress Controller âŒ› ğŸ¦©
        run: |
          echo "ğŸ¦© Waiting for NGINX Ingress Controller LoadBalancer IP..."
          while [ -z "$(kubectl get service ingress-nginx-controller -n ingress-nginx -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null)" ]; do
            sleep 10
            echo "ğŸ¦© Still waiting..."
          done
          echo "ğŸ‰ LoadBalancer IP is ready!"

      - name: Update DNS Records ğŸŒ ğŸ¦©
        run: |
          echo "ğŸ¦© Getting LoadBalancer IP..."
          LB_IP=$(kubectl get service ingress-nginx-controller -n ingress-nginx -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          echo "ğŸ¯ LoadBalancer IP is: ${LB_IP}"

          echo "ğŸ¦© Managing DNS records..."
          
          # Function to check if record exists and get its ID
          get_record_id() {
            local record_type=$1
            local record_name=$2
            doctl compute domain records list ${{ env.URL_SUFFIX }} --format ID,Type,Name --no-header | grep -i "^[0-9]* *${record_type} *${record_name}$" | awk '{print $1}'
          }

          # Handle A record for subdomain
          A_RECORD_ID=$(get_record_id "A" "${{ env.URL_PREFIX }}")
          if [ ! -z "$A_RECORD_ID" ]; then
            echo "ğŸ¦© A record exists with ID: ${A_RECORD_ID}"
            echo "ğŸ¦© Deleting old A record..."
            doctl compute domain records delete ${{ env.URL_SUFFIX }} $A_RECORD_ID --force
          fi
          
          echo "ğŸ¦© Creating new A record..."
          doctl compute domain records create ${{ env.URL_SUFFIX }} \
            --record-type A \
            --record-name "${{ env.URL_PREFIX }}" \
            --record-data "${LB_IP}"

          # Handle CNAME record for www subdomain
          CNAME_RECORD_ID=$(get_record_id "CNAME" "www.${{ env.URL_PREFIX }}")
          if [ ! -z "$CNAME_RECORD_ID" ]; then
            echo "ğŸ¦© CNAME record exists with ID: ${CNAME_RECORD_ID}"
            echo "ğŸ¦© Deleting old CNAME record..."
            doctl compute domain records delete ${{ env.URL_SUFFIX }} $CNAME_RECORD_ID --force
          fi
          
          echo "ğŸ¦© Creating new CNAME record..."
          doctl compute domain records create ${{ env.URL_SUFFIX }} \
            --record-type CNAME \
            --record-name "www.${{ env.URL_PREFIX }}" \
            --record-data "${{ env.URL_PREFIX }}.${{ env.URL_SUFFIX }}."

      - name: Update deployment file ğŸ“ ğŸ¦©
        run: |
          echo "ğŸ¦© Updating deployment configurations..."
          VERSION=v1.0.${{ github.run_number }}
          
          # Update backend deployment
          cat <<EOF | kubectl apply -f -
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: backend-deployment
          spec:
            replicas: 2
            selector:
              matchLabels:
                app: backend
            template:
              metadata:
                labels:
                  app: backend
              spec:
                containers:
                - name: backend
                  image: ${{ env.REGISTRY }}/${{ github.repository_owner }}/major-league-github-backend:${VERSION}
                  ports:
                  - containerPort: 8450
                  resources:
                    requests:
                      memory: "2Gi"
                      cpu: "1"
                    limits:
                      memory: "2560Mi"
                      cpu: "2"
                  env:
                  - name: github.tokens
                    valueFrom:
                      secretKeyRef:
                        name: github-tokens
                        key: github.tokens
                  - name: JAVA_TOOL_OPTIONS
                    value: "-Xmx1536m -Xms768m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp"
                imagePullSecrets:
                - name: github-registry
          EOF
          
          # Update frontend deployment
          cat <<EOF | kubectl apply -f -
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: frontend-deployment
          spec:
            replicas: 2
            selector:
              matchLabels:
                app: frontend
            template:
              metadata:
                labels:
                  app: frontend
              spec:
                containers:
                - name: frontend
                  image: ${{ env.REGISTRY }}/${{ github.repository_owner }}/major-league-github-frontend:${VERSION}
                  ports:
                  - containerPort: 80
                  resources:
                    requests:
                      memory: "256Mi"
                      cpu: "200m"
                    limits:
                      memory: "512Mi"
                      cpu: "500m"
                imagePullSecrets:
                - name: github-registry
          EOF

      - name: Create GitHub Tokens Secret ğŸ” ğŸ¦©
        run: |
          echo "ğŸ¦© Creating GitHub tokens secret..."
          cat <<EOF | kubectl apply -f -
          apiVersion: v1
          kind: Secret
          metadata:
            name: github-tokens
          type: Opaque
          stringData:
            github.tokens: ${{ secrets.GH_API_TOKENS }}
          EOF

      - name: Create TLS Certificate ğŸ”’ ğŸ¦©
        run: |
          echo "ğŸ¦© Setting up TLS certificate..."
          cat <<EOF | kubectl apply -f -
          apiVersion: cert-manager.io/v1
          kind: Certificate
          metadata:
            name: ${{ secrets.IMAGE_NAME }}-tls
            namespace: default
          spec:
            secretName: ${{ secrets.IMAGE_NAME }}-tls
            dnsNames:
            - ${{ env.URL_PREFIX }}.${{ env.URL_SUFFIX }}
            - www.${{ env.URL_PREFIX }}.${{ env.URL_SUFFIX }}
            issuerRef:
              name: letsencrypt-prod
              kind: ClusterIssuer
          EOF

      - name: Deploy to DigitalOcean Kubernetes ğŸš€ ğŸ¦©
        run: |
          echo "ğŸ¦© Deploying to Kubernetes..."
          
          # Create Ingress configuration with proper domain substitution
          cat <<EOF | kubectl apply -f -
          apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            name: frontend-ingress
            annotations:
              kubernetes.io/ingress.class: nginx
              cert-manager.io/cluster-issuer: letsencrypt-prod
              nginx.ingress.kubernetes.io/ssl-redirect: "true"
          spec:
            tls:
            - hosts:
              - ${{ env.URL_PREFIX }}.${{ env.URL_SUFFIX }}
              - www.${{ env.URL_PREFIX }}.${{ env.URL_SUFFIX }}
              secretName: ${{ secrets.IMAGE_NAME }}-tls
            rules:
            - host: ${{ env.URL_PREFIX }}.${{ env.URL_SUFFIX }}
              http:
                paths:
                - path: /
                  pathType: Prefix
                  backend:
                    service:
                      name: frontend-service
                      port:
                        number: 80
            - host: www.${{ env.URL_PREFIX }}.${{ env.URL_SUFFIX }}
              http:
                paths:
                - path: /
                  pathType: Prefix
                  backend:
                    service:
                      name: frontend-service
                      port:
                        number: 80
          EOF
          
          # Apply other Kubernetes configurations
          kubectl apply -f kubernetes/
          kubectl rollout restart deployment/backend-deployment
          kubectl rollout restart deployment/frontend-deployment
        env:
          URL_SUFFIX: ${{ env.URL_SUFFIX }}

      - name: Create Deployment ğŸ“¦ ğŸ¦©
        id: deployment
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_PAT }}
          script: |
            console.log("ğŸ¦© Creating deployment...");
            const deployment = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.sha,
              environment: 'production',
              auto_merge: false,
              required_contexts: []
            });
            return deployment.data.id;

      - name: Update Deployment Status âœ¨ ğŸ¦©
        if: success()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_PAT }}
          script: |
            console.log("ğŸ¦© Updating deployment status...");
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: ${{ steps.deployment.outputs.result }},
              state: 'success',
              environment_url: process.env.APP_URL,
              description: 'Deployment successful! :rocket:',
              log_url: `https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`
            }); 