name: Build and Deploy Major League Github ğŸš€ ğŸ¦©

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  REGISTRY: registry.digitalocean.com
  REGISTRY_NAME: major-league-github
  VERSION: v1.0.${{ github.run_number }}
  DOMAIN_NAME: major-league-github.flamingo.cx
  ENVIRONMENT: production
  BACKEND_REPLICAS: "2"
  FRONTEND_REPLICAS: "2"

jobs:
  build-and-deploy:
    runs-on: ubuntu-22.04
    permissions:
      contents: read
      packages: write
      deployments: write

    steps:
      - name: Checkout code ğŸ“¦
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}

      - name: Install doctl ğŸ› ï¸
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

      - name: Configure Docker and Kubernetes ğŸ”‘
        run: |
          echo "ğŸ¦© Setting up Docker..."
          doctl registry login --expiry-seconds 1800
          
          echo "ğŸ¦© Setting up Kubernetes..."
          doctl kubernetes cluster kubeconfig save --expiry-seconds 1800 ${{ secrets.CLUSTER_NAME }}
          
          echo "ğŸ¦© Creating registry credentials..."
          doctl registry docker-config > docker-config.json
          DOCKER_CONFIG_BASE64=$(base64 -w 0 docker-config.json)
          echo "DOCKER_CONFIG_BASE64=${DOCKER_CONFIG_BASE64}" >> $GITHUB_ENV

      - name: Build and push backend image ğŸ—ï¸ ğŸ¦©
        run: |
          echo "ğŸ¦© Building backend image..."
          docker build -t ${REGISTRY}/${REGISTRY_NAME}/backend:${VERSION} ./backend
          docker push ${REGISTRY}/${REGISTRY_NAME}/backend:${VERSION}
          
          echo "ğŸ¦© Tagging latest..."
          docker tag ${REGISTRY}/${REGISTRY_NAME}/backend:${VERSION} ${REGISTRY}/${REGISTRY_NAME}/backend:latest
          docker push ${REGISTRY}/${REGISTRY_NAME}/backend:latest

      - name: Build and push frontend image ğŸ¨ ğŸ¦©
        run: |
          echo "ğŸ¦© Building frontend image..."
          docker build -t ${REGISTRY}/${REGISTRY_NAME}/frontend:${VERSION} ./frontend
          docker push ${REGISTRY}/${REGISTRY_NAME}/frontend:${VERSION}
          
          echo "ğŸ¦© Tagging latest..."
          docker tag ${REGISTRY}/${REGISTRY_NAME}/frontend:${VERSION} ${REGISTRY}/${REGISTRY_NAME}/frontend:latest
          docker push ${REGISTRY}/${REGISTRY_NAME}/frontend:latest

      - name: Setup Kubernetes Dependencies ğŸ¯ ğŸ¦©
        run: |
          echo "ğŸ¦© Installing Helm..."
          curl https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3 | bash
          
          echo "ğŸ¦© Adding Helm repositories..."
          helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
          helm repo add jetstack https://charts.jetstack.io
          helm repo update
          
          echo "ğŸ¦© Installing NGINX Ingress Controller..."
          helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx \
            --namespace ingress-nginx --create-namespace \
            --set controller.publishService.enabled=true \
            --wait
          
          echo "ğŸ¦© Installing cert-manager..."
          helm upgrade --install cert-manager jetstack/cert-manager \
            --namespace cert-manager --create-namespace \
            --set installCRDs=true \
            --wait

      - name: Create Kubernetes Secrets ğŸ” ğŸ¦©
        run: |
          echo "ğŸ¦© Creating namespace if not exists..."
          kubectl create namespace ${REGISTRY_NAME} --dry-run=client -o yaml | kubectl apply -f -
          
          echo "ğŸ¦© Creating registry credentials..."
          kubectl create secret docker-registry registry-credentials \
            --namespace=${REGISTRY_NAME} \
            --docker-server=${REGISTRY} \
            --docker-username=${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }} \
            --docker-password=${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }} \
            --dry-run=client -o yaml | kubectl apply -f -
          
          echo "ğŸ¦© Creating application secrets..."
          kubectl create secret generic app-secrets \
            --namespace=${REGISTRY_NAME} \
            --from-literal=GITHUB_TOKENS=${{ secrets.GH_API_TOKENS }} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy Kubernetes Configurations ğŸš€ ğŸ¦©
        env:
          REGISTRY_URL: ${REGISTRY}/${REGISTRY_NAME}
          LETSENCRYPT_EMAIL: ${{ secrets.LETSENCRYPT_EMAIL }}
        run: |
          echo "ğŸ¦© Processing and applying Kubernetes configurations..."
          
          for file in kubernetes/base/*.yaml; do
            echo "ğŸ¦© Processing $file..."
            envsubst < $file | kubectl apply -n ${REGISTRY_NAME} -f -
          done
          
          echo "ğŸ¦© Waiting for deployments to be ready..."
          kubectl -n ${REGISTRY_NAME} rollout status deployment/backend
          kubectl -n ${REGISTRY_NAME} rollout status deployment/frontend

      - name: Update DNS Records ğŸŒ ğŸ¦©
        run: |
          echo "ğŸ¦© Getting LoadBalancer IP..."
          LB_IP=$(kubectl -n ingress-nginx get service ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          
          echo "ğŸ¦© Updating DNS A record..."
          doctl compute domain records create ${{ secrets.DOMAIN_SUFFIX }} \
            --record-type A \
            --record-name "major-league-github" \
            --record-data "${LB_IP}" \
            --record-ttl 300

      - name: Verify Deployment ğŸ” ğŸ¦©
        run: |
          echo "ğŸ¦© Checking pod status..."
          kubectl -n ${REGISTRY_NAME} get pods
          
          echo "ğŸ¦© Checking service status..."
          kubectl -n ${REGISTRY_NAME} get services
          
          echo "ğŸ¦© Checking ingress status..."
          kubectl -n ${REGISTRY_NAME} get ingress
          
          echo "ğŸ¦© Checking certificate status..."
          kubectl -n ${REGISTRY_NAME} get certificates

      - name: Create GitHub Deployment ğŸ“¦ ğŸ¦©
        uses: chrnorm/deployment-action@v2
        with:
          token: ${{ secrets.GH_PAT }}
          environment: production
          initial-status: success
          environment-url: https://${{ env.DOMAIN_NAME }} 