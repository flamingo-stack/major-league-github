name: Build and Deploy Major League Github üöÄ ü¶©

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  REGISTRY: registry.digitalocean.com
  REGISTRY_NAME: major-league-github
  VERSION: v1.0.${{ github.run_number }}
  DOMAIN_NAME: major-league-github.flamingo.cx
  ENVIRONMENT: production
  
  # Cluster configuration
  CLUSTER_NAME: ${{ secrets.CLUSTER_NAME }}
  CLUSTER_REGION: sfo3
  CLUSTER_SIZE: s-2vcpu-4gb
  CLUSTER_NODE_COUNT: "2"
  CLUSTER_VERSION: latest
  
  # Replica counts
  BACKEND_REPLICAS: "2"
  FRONTEND_REPLICAS: "2"
  
  # Backend resources
  BACKEND_REQUEST_MEMORY: "2048Mi"
  BACKEND_REQUEST_CPU: "1000m"
  BACKEND_LIMIT_MEMORY: "2560Mi"
  BACKEND_LIMIT_CPU: "2000m"
  
  # Frontend resources
  FRONTEND_REQUEST_MEMORY: "128Mi"
  FRONTEND_REQUEST_CPU: "100m"
  FRONTEND_LIMIT_MEMORY: "256Mi"
  FRONTEND_LIMIT_CPU: "200m"
  
  # Java settings
  JAVA_MAX_HEAP: "1536m"
  JAVA_MIN_HEAP: "768m"

jobs:
  build-and-deploy:
    runs-on: ubuntu-22.04
    permissions:
      contents: read
      packages: write
      deployments: write

    steps:
      - name: Verify Required Secrets üîí
        run: |
          missing_secrets=()
          
          if [ -z "${{ secrets.CLUSTER_NAME }}" ]; then
            missing_secrets+=("CLUSTER_NAME")
          fi
          
          if [ -z "${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}" ]; then
            missing_secrets+=("DIGITALOCEAN_ACCESS_TOKEN")
          fi
          
          if [ -z "${{ secrets.GH_PAT }}" ]; then
            missing_secrets+=("GH_PAT")
          fi
          
          if [ -z "${{ secrets.GH_API_TOKENS }}" ]; then
            missing_secrets+=("GH_API_TOKENS")
          fi
          
          if [ -z "${{ secrets.LETSENCRYPT_EMAIL }}" ]; then
            missing_secrets+=("LETSENCRYPT_EMAIL")
          fi
          
          if [ -z "${{ secrets.DOMAIN_SUFFIX }}" ]; then
            missing_secrets+=("DOMAIN_SUFFIX")
          fi
          
          if [ ${#missing_secrets[@]} -ne 0 ]; then
            echo "‚ùå Error: The following required secrets are missing:"
            printf '%s\n' "${missing_secrets[@]}"
            echo ""
            echo "Please add these secrets in your GitHub repository:"
            echo "1. Go to Settings ‚Üí Secrets and variables ‚Üí Actions"
            echo "2. Click on 'New repository secret'"
            echo "3. Add each missing secret with its value"
            echo ""
            echo "Required secrets and their purposes:"
            echo "- CLUSTER_NAME: Your DigitalOcean Kubernetes cluster name"
            echo "- DIGITALOCEAN_ACCESS_TOKEN: Your DigitalOcean API token"
            echo "- GH_PAT: GitHub Personal Access Token"
            echo "- GH_API_TOKENS: GitHub API tokens for the application"
            echo "- LETSENCRYPT_EMAIL: Email for SSL certificates"
            echo "- DOMAIN_SUFFIX: Domain suffix (e.g., 'flamingo.cx')"
            exit 1
          fi
          
          echo "‚úÖ All required secrets are set"

      - name: Checkout code üì¶
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}

      - name: Install doctl üõ†Ô∏è
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

      - name: Setup DigitalOcean Infrastructure üèóÔ∏è
        run: |
          echo "ü¶© Checking DigitalOcean Registry..."
          if ! doctl registry get; then
            echo "ü¶© Creating DigitalOcean Registry..."
            if ! doctl registry create --subscription-tier basic; then
              echo "‚ùå Error: Failed to create registry"
              exit 1
            fi
            echo "‚úÖ Registry created successfully"
          else
            echo "‚úÖ Registry already exists"
          fi
          
          echo "ü¶© Checking Kubernetes cluster..."
          if ! doctl kubernetes cluster get "$CLUSTER_NAME" 2>/dev/null; then
            echo "ü¶© Creating Kubernetes cluster..."
            if ! doctl kubernetes cluster create "$CLUSTER_NAME" \
              --region $CLUSTER_REGION \
              --size $CLUSTER_SIZE \
              --count $CLUSTER_NODE_COUNT \
              --version $CLUSTER_VERSION \
              --auto-upgrade true \
              --maintenance-window "saturday=21:00" \
              --ha=true \
              --wait; then
              echo "‚ùå Error: Failed to create cluster"
              exit 1
            fi
            echo "‚úÖ Cluster created successfully"
          else
            echo "‚úÖ Cluster already exists"
          fi

      - name: Configure Docker and Kubernetes üîë
        run: |
          echo "ü¶© Setting up Docker..."
          if ! doctl registry login --expiry-seconds 1800; then
            echo "‚ùå Error: Failed to log in to Docker registry"
            exit 1
          fi
          
          echo "ü¶© Setting up Kubernetes..."
          if ! doctl kubernetes cluster kubeconfig save "$CLUSTER_NAME" --expiry-seconds 1800; then
            echo "‚ùå Error: Failed to save Kubernetes config"
            exit 1
          fi
          
          echo "ü¶© Verifying Kubernetes connection..."
          if ! kubectl cluster-info; then
            echo "‚ùå Error: Failed to connect to Kubernetes cluster"
            exit 1
          fi
          
          echo "ü¶© Creating registry credentials..."
          if ! doctl registry docker-config > docker-config.json; then
            echo "‚ùå Error: Failed to get Docker config"
            exit 1
          fi
          
          DOCKER_CONFIG_BASE64=$(base64 -w 0 docker-config.json)
          echo "DOCKER_CONFIG_BASE64=${DOCKER_CONFIG_BASE64}" >> $GITHUB_ENV
          
          echo "‚úÖ Configuration completed successfully"

      - name: Build and push backend image üèóÔ∏è ü¶©
        run: |
          echo "ü¶© Building backend image..."
          if ! docker build -t ${REGISTRY}/${REGISTRY_NAME}/backend:${VERSION} ./backend; then
            echo "‚ùå Error: Failed to build backend image"
            exit 1
          fi
          
          echo "ü¶© Pushing versioned backend image..."
          if ! docker push ${REGISTRY}/${REGISTRY_NAME}/backend:${VERSION}; then
            echo "‚ùå Error: Failed to push backend versioned image"
            exit 1
          fi
          
          echo "ü¶© Tagging and pushing latest..."
          docker tag ${REGISTRY}/${REGISTRY_NAME}/backend:${VERSION} ${REGISTRY}/${REGISTRY_NAME}/backend:latest
          if ! docker push ${REGISTRY}/${REGISTRY_NAME}/backend:latest; then
            echo "‚ùå Error: Failed to push backend latest image"
            exit 1
          fi
          
          echo "‚úÖ Backend image build and push completed"

      - name: Build and push frontend image üé® ü¶©
        run: |
          echo "ü¶© Building frontend image..."
          if ! docker build -t ${REGISTRY}/${REGISTRY_NAME}/frontend:${VERSION} ./frontend; then
            echo "‚ùå Error: Failed to build frontend image"
            exit 1
          fi
          
          echo "ü¶© Pushing versioned frontend image..."
          if ! docker push ${REGISTRY}/${REGISTRY_NAME}/frontend:${VERSION}; then
            echo "‚ùå Error: Failed to push frontend versioned image"
            exit 1
          fi
          
          echo "ü¶© Tagging and pushing latest..."
          docker tag ${REGISTRY}/${REGISTRY_NAME}/frontend:${VERSION} ${REGISTRY}/${REGISTRY_NAME}/frontend:latest
          if ! docker push ${REGISTRY}/${REGISTRY_NAME}/frontend:latest; then
            echo "‚ùå Error: Failed to push frontend latest image"
            exit 1
          fi
          
          echo "‚úÖ Frontend image build and push completed"

      - name: Setup Kubernetes Dependencies üéØ ü¶©
        run: |
          echo "ü¶© Installing Helm..."
          if ! curl -fsSL https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3 | bash; then
            echo "‚ùå Error: Failed to install Helm"
            exit 1
          fi
          
          echo "ü¶© Adding Helm repositories..."
          helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
          helm repo add jetstack https://charts.jetstack.io
          helm repo update
          
          echo "ü¶© Installing NGINX Ingress Controller..."
          if ! helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx \
            --namespace ingress-nginx --create-namespace \
            --set controller.publishService.enabled=true \
            --wait --timeout 5m; then
            echo "‚ùå Error: Failed to install NGINX Ingress"
            exit 1
          fi
          
          echo "ü¶© Installing cert-manager..."
          if ! helm upgrade --install cert-manager jetstack/cert-manager \
            --namespace cert-manager --create-namespace \
            --set installCRDs=true \
            --wait --timeout 5m; then
            echo "‚ùå Error: Failed to install cert-manager"
            exit 1
          fi
          
          echo "‚úÖ Kubernetes dependencies setup completed"

      - name: Create Kubernetes Secrets üîê ü¶©
        run: |
          echo "ü¶© Creating namespace if not exists..."
          if ! kubectl create namespace ${REGISTRY_NAME} --dry-run=client -o yaml | kubectl apply -f -; then
            echo "‚ùå Error: Failed to create namespace"
            exit 1
          fi
          
          echo "ü¶© Creating registry credentials..."
          if ! kubectl create secret docker-registry registry-credentials \
            --namespace=${REGISTRY_NAME} \
            --docker-server=${REGISTRY} \
            --docker-username=${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }} \
            --docker-password=${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }} \
            --dry-run=client -o yaml | kubectl apply -f -; then
            echo "‚ùå Error: Failed to create registry credentials"
            exit 1
          fi
          
          echo "ü¶© Creating application secrets..."
          # Create a temporary file for the tokens
          echo "${{ secrets.GH_API_TOKENS }}" > github_tokens.txt
          
          if ! kubectl create secret generic app-secrets \
            --namespace=${REGISTRY_NAME} \
            --from-file=github.tokens=github_tokens.txt \
            --dry-run=client -o yaml | kubectl apply -f -; then
            echo "‚ùå Error: Failed to create application secrets"
            rm -f github_tokens.txt
            exit 1
          fi
          
          # Clean up the temporary file
          rm -f github_tokens.txt
          
          echo "‚úÖ Kubernetes secrets created successfully"

      - name: Deploy Kubernetes Configurations üöÄ ü¶©
        env:
          REGISTRY_URL: ${REGISTRY}/${REGISTRY_NAME}
          LETSENCRYPT_EMAIL: ${{ secrets.LETSENCRYPT_EMAIL }}
        run: |
          echo "ü¶© Processing and applying Kubernetes configurations..."
          
          for file in kubernetes/base/*.yaml; do
            echo "ü¶© Processing $file..."
            if ! envsubst < $file | kubectl apply -n ${REGISTRY_NAME} -f -; then
              echo "‚ùå Error: Failed to apply $file"
              exit 1
            fi
          done
          
          echo "ü¶© Waiting for deployments to be ready..."
          
          # Function to check pod status and logs
          check_deployment() {
            local deployment=$1
            echo "ü¶© Checking status for deployment: $deployment"
            
            # Get pod status
            echo "ü¶© Pod status:"
            kubectl -n ${REGISTRY_NAME} get pods -l app=$deployment -o wide
            
            # Get failed pods if any
            failed_pods=$(kubectl -n ${REGISTRY_NAME} get pods -l app=$deployment -o jsonpath='{.items[?(@.status.phase!="Running")].metadata.name}')
            
            if [ ! -z "$failed_pods" ]; then
              echo "ü¶© Found failed pods: $failed_pods"
              for pod in $failed_pods; do
                echo "ü¶© Logs for failed pod $pod:"
                kubectl -n ${REGISTRY_NAME} logs $pod --all-containers --tail=50
                
                echo "ü¶© Events for failed pod $pod:"
                kubectl -n ${REGISTRY_NAME} get events --field-selector involvedObject.name=$pod
                
                echo "ü¶© Describing failed pod $pod:"
                kubectl -n ${REGISTRY_NAME} describe pod $pod
              done
            fi
          }
          
          # Wait for backend deployment
          echo "ü¶© Waiting for backend deployment..."
          if ! kubectl -n ${REGISTRY_NAME} rollout status deployment/backend --timeout=5m; then
            echo "‚ùå Error: Backend deployment failed to roll out"
            check_deployment "backend"
            exit 1
          fi
          
          # Wait for frontend deployment
          echo "ü¶© Waiting for frontend deployment..."
          if ! kubectl -n ${REGISTRY_NAME} rollout status deployment/frontend --timeout=5m; then
            echo "‚ùå Error: Frontend deployment failed to roll out"
            check_deployment "frontend"
            exit 1
          fi
          
          echo "‚úÖ Kubernetes configurations deployed successfully"

      - name: Update DNS Records üåç ü¶©
        run: |
          echo "ü¶© Getting LoadBalancer IP..."
          LB_IP=""
          RETRY_COUNT=0
          MAX_RETRIES=30
          
          while [ -z "$LB_IP" ] && [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            LB_IP=$(kubectl -n ingress-nginx get service ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
            if [ -z "$LB_IP" ]; then
              echo "ü¶© Waiting for LoadBalancer IP... (Attempt $((RETRY_COUNT + 1))/$MAX_RETRIES)"
              sleep 10
              RETRY_COUNT=$((RETRY_COUNT + 1))
            fi
          done
          
          if [ -z "$LB_IP" ]; then
            echo "‚ùå Error: Failed to get LoadBalancer IP after $MAX_RETRIES attempts"
            exit 1
          fi
          
          echo "ü¶© Updating DNS A record..."
          if ! doctl compute domain records create ${{ secrets.DOMAIN_SUFFIX }} \
            --record-type A \
            --record-name "major-league-github" \
            --record-data "${LB_IP}" \
            --record-ttl 300; then
            echo "‚ùå Error: Failed to update DNS record"
            exit 1
          fi
          
          echo "‚úÖ DNS records updated successfully"

      - name: Verify Deployment üîç ü¶©
        run: |
          echo "ü¶© Checking deployment status..."
          
          echo "ü¶© Pod Status:"
          kubectl -n ${REGISTRY_NAME} get pods -o wide
          
          echo "ü¶© Service Status:"
          kubectl -n ${REGISTRY_NAME} get services
          
          echo "ü¶© Ingress Status:"
          kubectl -n ${REGISTRY_NAME} get ingress
          
          echo "ü¶© Certificate Status:"
          kubectl -n ${REGISTRY_NAME} get certificates
          
          echo "ü¶© Events:"
          kubectl -n ${REGISTRY_NAME} get events --sort-by='.lastTimestamp'
          
          # Verify all pods are running
          failed_pods=$(kubectl -n ${REGISTRY_NAME} get pods -o jsonpath='{.items[?(@.status.phase!="Running")].metadata.name}')
          if [ ! -z "$failed_pods" ]; then
            echo "‚ùå Error: The following pods are not running:"
            echo "$failed_pods"
            
            for pod in $failed_pods; do
              echo "ü¶© Describing failed pod $pod:"
              kubectl -n ${REGISTRY_NAME} describe pod $pod
              
              echo "ü¶© Logs for failed pod $pod:"
              kubectl -n ${REGISTRY_NAME} logs $pod --all-containers --tail=50 || true
            done
            exit 1
          fi
          
          echo "‚úÖ Deployment verification completed"

      - name: Create GitHub Deployment üì¶ ü¶©
        uses: chrnorm/deployment-action@v2
        with:
          token: ${{ secrets.GH_PAT }}
          environment: production
          initial-status: success
          environment-url: https://${{ env.DOMAIN_NAME }} 