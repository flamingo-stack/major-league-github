name: Build and Deploy Major League Github üöÄ ü¶©

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  REGISTRY: registry.digitalocean.com
  REGISTRY_NAME: major-league-github
  URL_SUFFIX: "flamingo.cx"
  URL_PREFIX: "major-league-github"
  APP_URL: "https://major-league-github.flamingo.cx"
  

jobs:
  build-and-deploy:
    runs-on: ubuntu-22.04
    permissions:
      contents: read
      packages: write
      deployments: write

    steps:
      - name: Checkout code üì¶
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}

      - name: Install doctl üõ†Ô∏è
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

      - name: Configure Docker üîë
        run: |
          echo "ü¶© Setting up Docker config..."
          mkdir -p ~/.docker
          
          # Create Docker config with registry auth
          cat > ~/.docker/config.json << EOF
          {
            "auths": {
              "registry.digitalocean.com": {
                "auth": "$(echo -n "${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}:${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}" | base64)"
              }
            }
          }
          EOF
          
          # Verify config
          cat ~/.docker/config.json

      - name: Build and push backend image üèóÔ∏è ü¶©
        run: |
          echo "ü¶© Building backend image..."
          docker build -t registry.digitalocean.com/${{ env.REGISTRY_NAME }}/${{ secrets.IMAGE_NAME }}-backend:latest ./backend
          
          echo "ü¶© Pushing backend image..."
          docker push registry.digitalocean.com/${{ env.REGISTRY_NAME }}/${{ secrets.IMAGE_NAME }}-backend:latest
          
          echo "ü¶© Tagging version..."
          docker tag registry.digitalocean.com/${{ env.REGISTRY_NAME }}/${{ secrets.IMAGE_NAME }}-backend:latest registry.digitalocean.com/${{ env.REGISTRY_NAME }}/${{ secrets.IMAGE_NAME }}-backend:v1.0.${{ github.run_number }}
          
          echo "ü¶© Pushing version tag..."
          docker push registry.digitalocean.com/${{ env.REGISTRY_NAME }}/${{ secrets.IMAGE_NAME }}-backend:v1.0.${{ github.run_number }}

      - name: Build and push frontend image üé® ü¶©
        run: |
          echo "ü¶© Building frontend image..."
          docker build -t registry.digitalocean.com/${{ env.REGISTRY_NAME }}/${{ secrets.IMAGE_NAME }}-frontend:latest ./frontend --no-cache --username ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }} --password ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}
          docker push registry.digitalocean.com/${{ env.REGISTRY_NAME }}/${{ secrets.IMAGE_NAME }}-frontend:latest --username ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }} --password ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}
          docker tag registry.digitalocean.com/${{ env.REGISTRY_NAME }}/${{ secrets.IMAGE_NAME }}-frontend:latest registry.digitalocean.com/${{ env.REGISTRY_NAME }}/${{ secrets.IMAGE_NAME }}-frontend:v1.0.${{ github.run_number }} --no-cache --username ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }} --password ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}
          docker push registry.digitalocean.com/${{ env.REGISTRY_NAME }}/${{ secrets.IMAGE_NAME }}-frontend:v1.0.${{ github.run_number }} --no-cache --username ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }} --password ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

      - name: Configure Kubernetes registry access üîë
        run: |
          echo "ü¶© Creating registry secret in Kubernetes..."
          kubectl delete secret registry-major-league-github --ignore-not-found
          doctl registry kubernetes-manifest | kubectl apply -f -
          
          echo "ü¶© Patching default service account..."
          kubectl patch serviceaccount default -p '{"imagePullSecrets": [{"name": "registry-major-league-github"}]}'

      - name: Install Helm ‚öì
        run: |
          echo "ü¶© Installing Helm..."
          cURL https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3 | bash

      - name: Install NGINX Ingress Controller üåê ü¶©
        run: |
          echo "ü¶© Setting up NGINX Ingress..."
          helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
          helm repo update
          helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx \
            --namespace ingress-nginx --create-namespace \
            --set controller.publishService.enabled=true
          
          echo "ü¶© Waiting for NGINX Ingress pods to be ready..."
          kubectl wait --namespace ingress-nginx \
            --for=condition=ready pod \
            --selector=app.kubernetes.io/component=controller \
            --timeout=120s

      - name: Install cert-manager üîí ü¶©
        run: |
          echo "ü¶© Setting up cert-manager..."
          helm repo add jetstack https://charts.jetstack.io
          helm repo update
          
          # Check if there's any Helm operation in progress
          echo "ü¶© Checking for ongoing Helm operations..."
          while helm list --pending -A | grep -q "pending"; do
            echo "ü¶© Waiting for other Helm operations to complete..."
            sleep 10
          done
          
          helm upgrade --install cert-manager jetstack/cert-manager \
            --namespace cert-manager --create-namespace \
            --set installCRDs=true

      - name: Wait for cert-manager to be ready ‚è≥
        run: |
          echo "ü¶© Waiting for cert-manager..."
          kubectl wait --for=condition=ready pod -l app.kubernetes.io/instance=cert-manager -n cert-manager --timeout=300s

      - name: Create ClusterIssuer üîë ü¶©
        run: |
          echo "ü¶© Creating Let's Encrypt ClusterIssuer..."
          cat <<EOF | kubectl apply -f -
          apiVersion: cert-manager.io/v1
          kind: ClusterIssuer
          metadata:
            name: letsencrypt-prod
          spec:
            acme:
              server: https://acme-v02.api.letsencrypt.org/directory
              email: ${LETSENCRYPT_EMAIL}
              privateKeySecretRef:
                name: letsencrypt-prod
              solvers:
              - http01:
                  ingress:
                    class: nginx
          EOF
        env:
          LETSENCRYPT_EMAIL: ${{ secrets.LETSENCRYPT_EMAIL }}

      - name: Wait for NGINX Ingress Controller ‚åõ ü¶©
        run: |
          echo "ü¶© Waiting for NGINX Ingress Controller LoadBalancer IP..."
          while [ -z "$(kubectl get service ingress-nginx-controller -n ingress-nginx -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null)" ]; do
            sleep 10
            echo "ü¶© Still waiting..."
          done
          echo "üéâ LoadBalancer IP is ready!"

      - name: Update DNS Records üåç ü¶©
        run: |
          echo "ü¶© Getting LoadBalancer IP..."
          LB_IP=$(kubectl get service ingress-nginx-controller -n ingress-nginx -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          echo "üéØ LoadBalancer IP is: ${LB_IP}"

          echo "ü¶© Managing DNS records..."
          
          # Function to check if record exists and get its ID
          get_record_id() {
            local record_type=$1
            local record_name=$2
            doctl compute domain records list ${{ env.URL_SUFFIX }} --format ID,Type,Name --no-header | grep -i "^[0-9]* *${record_type} *${record_name}$" | awk '{print $1}'
          }

          # Handle A record for subdomain
          A_RECORD_ID=$(get_record_id "A" "${{ env.URL_PREFIX }}")
          if [ ! -z "$A_RECORD_ID" ]; then
            echo "ü¶© A record exists with ID: ${A_RECORD_ID}"
            echo "ü¶© Deleting old A record..."
            doctl compute domain records delete ${{ env.URL_SUFFIX }} $A_RECORD_ID --force
          fi
          
          echo "ü¶© Creating new A record..."
          doctl compute domain records create ${{ env.URL_SUFFIX }} \
            --record-type A \
            --record-name "${{ env.URL_PREFIX }}" \
            --record-data "${LB_IP}"

          # Handle CNAME record for www subdomain
          CNAME_RECORD_ID=$(get_record_id "CNAME" "www.${{ env.URL_PREFIX }}")
          if [ ! -z "$CNAME_RECORD_ID" ]; then
            echo "ü¶© CNAME record exists with ID: ${CNAME_RECORD_ID}"
            echo "ü¶© Deleting old CNAME record..."
            doctl compute domain records delete ${{ env.URL_SUFFIX }} $CNAME_RECORD_ID --force
          fi
          
          echo "ü¶© Creating new CNAME record..."
          doctl compute domain records create ${{ env.URL_SUFFIX }} \
            --record-type CNAME \
            --record-name "www.${{ env.URL_PREFIX }}" \
            --record-data "${{ env.URL_PREFIX }}.${{ env.URL_SUFFIX }}."

      - name: Update deployment file üìù ü¶©
        run: |
          echo "ü¶© Updating deployment configurations..."
          VERSION=v1.0.${{ github.run_number }}
          
          # Update backend deployment
          cat <<EOF | kubectl apply -f -
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: backend-deployment
          spec:
            replicas: 2
            selector:
              matchLabels:
                app: backend
            template:
              metadata:
                labels:
                  app: backend
              spec:
                containers:
                - name: backend
                  image: ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/backend:${VERSION}
                  ports:
                  - containerPort: 8450
                  resources:
                    requests:
                      memory: "1Gi"
                      cpu: "500m"
                    limits:
                      memory: "1536Mi"
                      cpu: "1"
                  env:
                  - name: github.tokens
                    valueFrom:
                      secretKeyRef:
                        name: github-tokens
                        key: github.tokens
                  - name: JAVA_TOOL_OPTIONS
                    value: "-Xmx1024m -Xms512m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp"
                imagePullSecrets:
                - name: registry-major-league-github
          EOF
          
          # Update frontend deployment
          cat <<EOF | kubectl apply -f -
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: frontend-deployment
          spec:
            replicas: 2
            selector:
              matchLabels:
                app: frontend
            template:
              metadata:
                labels:
                  app: frontend
              spec:
                containers:
                - name: frontend
                  image: ${{ env.REGISTRY }}/${{ env.REGISTRY_NAME }}/frontend:${VERSION}
                  ports:
                  - containerPort: 80
                  resources:
                    requests:
                      memory: "128Mi"
                      cpu: "100m"
                    limits:
                      memory: "256Mi"
                      cpu: "200m"
                imagePullSecrets:
                - name: registry-major-league-github
          EOF

      - name: Create GitHub Tokens Secret üîê ü¶©
        run: |
          echo "ü¶© Creating GitHub tokens secret..."
          cat <<EOF | kubectl apply -f -
          apiVersion: v1
          kind: Secret
          metadata:
            name: github-tokens
          type: Opaque
          stringData:
            github.tokens: ${{ secrets.GH_API_TOKENS }}
          EOF

      - name: Create TLS Certificate üîí ü¶©
        run: |
          echo "ü¶© Setting up TLS certificate..."
          cat <<EOF | kubectl apply -f -
          apiVersion: cert-manager.io/v1
          kind: Certificate
          metadata:
            name: ${{ secrets.IMAGE_NAME }}-tls
            namespace: default
          spec:
            secretName: ${{ secrets.IMAGE_NAME }}-tls
            dnsNames:
            - ${{ env.URL_PREFIX }}.${{ env.URL_SUFFIX }}
            - www.${{ env.URL_PREFIX }}.${{ env.URL_SUFFIX }}
            issuerRef:
              name: letsencrypt-prod
              kind: ClusterIssuer
          EOF

      - name: Deploy to DigitalOcean Kubernetes üöÄ ü¶©
        run: |
          echo "ü¶© Deploying to Kubernetes..."
          
          # Create Ingress configuration with proper domain substitution
          cat <<EOF | kubectl apply -f -
          apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            name: frontend-ingress
            annotations:
              kubernetes.io/ingress.class: nginx
              cert-manager.io/cluster-issuer: letsencrypt-prod
              nginx.ingress.kubernetes.io/ssl-redirect: "true"
          spec:
            tls:
            - hosts:
              - ${{ env.URL_PREFIX }}.${{ env.URL_SUFFIX }}
              - www.${{ env.URL_PREFIX }}.${{ env.URL_SUFFIX }}
              secretName: ${{ secrets.IMAGE_NAME }}-tls
            rules:
            - host: ${{ env.URL_PREFIX }}.${{ env.URL_SUFFIX }}
              http:
                paths:
                - path: /
                  pathType: Prefix
                  backend:
                    service:
                      name: frontend-service
                      port:
                        number: 80
            - host: www.${{ env.URL_PREFIX }}.${{ env.URL_SUFFIX }}
              http:
                paths:
                - path: /
                  pathType: Prefix
                  backend:
                    service:
                      name: frontend-service
                      port:
                        number: 80
          EOF
          
          # Apply other Kubernetes configurations
          kubectl apply -f kubernetes/
          kubectl rollout restart deployment/backend-deployment
          kubectl rollout restart deployment/frontend-deployment
        env:
          URL_SUFFIX: ${{ env.URL_SUFFIX }}

      - name: Create Deployment üì¶ ü¶©
        id: deployment
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_PAT }}
          script: |
            console.log("ü¶© Creating deployment...");
            const deployment = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.sha,
              environment: 'production',
              auto_merge: false,
              required_contexts: []
            });
            return deployment.data.id;

      - name: Update Deployment Status ‚ú® ü¶©
        if: success()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_PAT }}
          script: |
            console.log("ü¶© Updating deployment status...");
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: ${{ steps.deployment.outputs.result }},
              state: 'success',
              environment_url: process.env.APP_URL,
              description: 'Deployment successful! :rocket:',
              log_url: `https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`
            }); 